
ariadne_atmega1284p_debug_16mhz_blink_shield_avrdevelopersstandard.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001c  00800100  0001f0a2  00001136  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000010a2  0001e000  0001e000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000000f  0080011c  0080011c  00001152  2**0
                  ALLOC
  3 .comment      00000011  00000000  00000000  00001152  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000178  00000000  00000000  00001163  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000029c5  00000000  00000000  000012db  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000d9b  00000000  00000000  00003ca0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00001964  00000000  00000000  00004a3b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000004c8  00000000  00000000  000063a0  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000008c3  00000000  00000000  00006868  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00001b13  00000000  00000000  0000712b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000000a0  00000000  00000000  00008c3e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0001e000 <__vectors>:
   1e000:	74 c1       	rjmp	.+744    	; 0x1e2ea <__ctors_end>
   1e002:	00 00       	nop
   1e004:	fc c1       	rjmp	.+1016   	; 0x1e3fe <__bad_interrupt>
   1e006:	00 00       	nop
   1e008:	fa c1       	rjmp	.+1012   	; 0x1e3fe <__bad_interrupt>
   1e00a:	00 00       	nop
   1e00c:	f8 c1       	rjmp	.+1008   	; 0x1e3fe <__bad_interrupt>
   1e00e:	00 00       	nop
   1e010:	f6 c1       	rjmp	.+1004   	; 0x1e3fe <__bad_interrupt>
   1e012:	00 00       	nop
   1e014:	f4 c1       	rjmp	.+1000   	; 0x1e3fe <__bad_interrupt>
   1e016:	00 00       	nop
   1e018:	f2 c1       	rjmp	.+996    	; 0x1e3fe <__bad_interrupt>
   1e01a:	00 00       	nop
   1e01c:	f0 c1       	rjmp	.+992    	; 0x1e3fe <__bad_interrupt>
   1e01e:	00 00       	nop
   1e020:	ee c1       	rjmp	.+988    	; 0x1e3fe <__bad_interrupt>
   1e022:	00 00       	nop
   1e024:	ec c1       	rjmp	.+984    	; 0x1e3fe <__bad_interrupt>
   1e026:	00 00       	nop
   1e028:	ea c1       	rjmp	.+980    	; 0x1e3fe <__bad_interrupt>
   1e02a:	00 00       	nop
   1e02c:	e8 c1       	rjmp	.+976    	; 0x1e3fe <__bad_interrupt>
   1e02e:	00 00       	nop
   1e030:	e6 c1       	rjmp	.+972    	; 0x1e3fe <__bad_interrupt>
   1e032:	00 00       	nop
   1e034:	e4 c1       	rjmp	.+968    	; 0x1e3fe <__bad_interrupt>
   1e036:	00 00       	nop
   1e038:	e2 c1       	rjmp	.+964    	; 0x1e3fe <__bad_interrupt>
   1e03a:	00 00       	nop
   1e03c:	e0 c1       	rjmp	.+960    	; 0x1e3fe <__bad_interrupt>
   1e03e:	00 00       	nop
   1e040:	de c1       	rjmp	.+956    	; 0x1e3fe <__bad_interrupt>
   1e042:	00 00       	nop
   1e044:	dc c1       	rjmp	.+952    	; 0x1e3fe <__bad_interrupt>
   1e046:	00 00       	nop
   1e048:	da c1       	rjmp	.+948    	; 0x1e3fe <__bad_interrupt>
   1e04a:	00 00       	nop
   1e04c:	d8 c1       	rjmp	.+944    	; 0x1e3fe <__bad_interrupt>
   1e04e:	00 00       	nop
   1e050:	d6 c1       	rjmp	.+940    	; 0x1e3fe <__bad_interrupt>
   1e052:	00 00       	nop
   1e054:	d4 c1       	rjmp	.+936    	; 0x1e3fe <__bad_interrupt>
   1e056:	00 00       	nop
   1e058:	d2 c1       	rjmp	.+932    	; 0x1e3fe <__bad_interrupt>
   1e05a:	00 00       	nop
   1e05c:	d0 c1       	rjmp	.+928    	; 0x1e3fe <__bad_interrupt>
   1e05e:	00 00       	nop
   1e060:	ce c1       	rjmp	.+924    	; 0x1e3fe <__bad_interrupt>
   1e062:	00 00       	nop
   1e064:	cc c1       	rjmp	.+920    	; 0x1e3fe <__bad_interrupt>
   1e066:	00 00       	nop
   1e068:	ca c1       	rjmp	.+916    	; 0x1e3fe <__bad_interrupt>
   1e06a:	00 00       	nop
   1e06c:	c8 c1       	rjmp	.+912    	; 0x1e3fe <__bad_interrupt>
   1e06e:	00 00       	nop
   1e070:	c6 c1       	rjmp	.+908    	; 0x1e3fe <__bad_interrupt>
   1e072:	00 00       	nop
   1e074:	c4 c1       	rjmp	.+904    	; 0x1e3fe <__bad_interrupt>
   1e076:	00 00       	nop
   1e078:	c2 c1       	rjmp	.+900    	; 0x1e3fe <__bad_interrupt>
   1e07a:	00 00       	nop
   1e07c:	c0 c1       	rjmp	.+896    	; 0x1e3fe <__bad_interrupt>
   1e07e:	00 00       	nop
   1e080:	be c1       	rjmp	.+892    	; 0x1e3fe <__bad_interrupt>
   1e082:	00 00       	nop
   1e084:	bc c1       	rjmp	.+888    	; 0x1e3fe <__bad_interrupt>
   1e086:	00 00       	nop
   1e088:	ba c1       	rjmp	.+884    	; 0x1e3fe <__bad_interrupt>
	...

0001e08c <__trampolines_end>:
   1e08c:	53 74       	andi	r21, 0x43	; 67
   1e08e:	61 72       	andi	r22, 0x21	; 33
   1e090:	74 20       	and	r7, r4
   1e092:	75 73       	andi	r23, 0x35	; 53
   1e094:	65 72       	andi	r22, 0x25	; 37
   1e096:	20 61       	ori	r18, 0x10	; 16
   1e098:	70 70       	andi	r23, 0x00	; 0
	...

0001e09b <mDebugMain_TITLE>:
   1e09b:	41 72 69 61 64 6e 65 20 66 6f 72 20 41 54 6d 65     Ariadne for ATme
   1e0ab:	67 61 31 32 38 34 50 2c 20 56 65 72 73 69 6f 6e     ga1284P, Version
   1e0bb:	20 30 2e 35 00                                       0.5.

0001e0c0 <mDebugMain_PREFIX>:
   1e0c0:	4d 61 69 6e 3a 20 00                                Main: .

0001e0c7 <mDebugNet_DONE>:
   1e0c7:	4e 65 74 77 6f 72 6b 20 69 6e 69 74 20 64 6f 6e     Network init don
   1e0d7:	65 00                                               e.

0001e0d9 <mDebugNet_MAC>:
   1e0d9:	09 20 20 20 20 4d 41 43 3a 20 00                    .    MAC: .

0001e0e4 <mDebugNet_GW>:
   1e0e4:	09 47 61 74 65 77 61 79 3a 20 00                    .Gateway: .

0001e0ef <mDebugNet_SUBN>:
   1e0ef:	09 20 53 75 62 6e 65 74 3a 20 00                    . Subnet: .

0001e0fa <mDebugNet_ADDR>:
   1e0fa:	09 41 64 64 72 65 73 73 3a 20 00                    .Address: .

0001e105 <mDebugNet_BUILTIN>:
   1e105:	42 75 69 6c 74 2d 69 6e 20 73 65 74 74 69 6e 67     Built-in setting
   1e115:	73 00                                               s.

0001e117 <mDebugNet_EEPROM>:
   1e117:	45 45 50 52 4f 4d 20 73 65 74 74 69 6e 67 73 00     EEPROM settings.

0001e127 <mDebugNet_PREFIX>:
   1e127:	20 4e 65 74 3a 20 00                                 Net: .

0001e12e <tftp_invalid_image_packet>:
   1e12e:	13 00 05 00 00 49 6e 76 61 6c 69 64 20 69 6d 61     .....Invalid ima
   1e13e:	67 65 20 66 69 6c 65 00                             ge file.

0001e146 <tftp_unknown_error_packet>:
   1e146:	08 00 05 00 00 45 72 72 6f 72 00                    .....Error.

0001e151 <tftp_full_error_packet>:
   1e151:	09 00 05 00 03 46 75 6c 6c 00                       .....Full.

0001e15b <tftp_opcode_error_packet>:
   1e15b:	0a 00 05 00 00 4f 70 63 6f 64 65 3f 00              .....Opcode?.

0001e168 <mDebugTftp_SOCK>:
   1e168:	49 6e 69 74 20 73 6f 63 6b 65 74 20 74 6f 20 70     Init socket to p
   1e178:	6f 72 74 20 00                                      ort .

0001e17d <mDebugTftp_PORT>:
   1e17d:	09 44 61 74 61 50 6f 72 74 3a 20 00                 .DataPort: .

0001e189 <mDebugTftp_INIT>:
   1e189:	54 46 54 50 20 73 65 72 76 65 72 20 69 6e 69 74     TFTP server init
   1e199:	20 64 6f 6e 65 00                                    done.

0001e19f <mDebugTftp_RESP>:
   1e19f:	52 65 73 70 6f 6e 73 65 20 73 65 6e 74 00           Response sent.

0001e1ad <mDebugTftp_SFACK>:
   1e1ad:	53 65 6e 74 20 46 69 6e 61 6c 20 41 43 4b 00        Sent Final ACK.

0001e1bc <mDebugTftp_SACK>:
   1e1bc:	53 65 6e 74 20 41 43 4b 00                          Sent ACK.

0001e1c5 <mDebugTftp_INVOP>:
   1e1c5:	49 6e 76 61 6c 69 64 20 6f 70 63 6f 64 65 20 00     Invalid opcode .

0001e1d5 <mDebugTftp_OPERR>:
   1e1d5:	45 72 72 6f 72 00                                   Error.

0001e1db <mDebugTftp_OPACK>:
   1e1db:	41 63 6b 6e 6f 77 6c 65 64 67 65 00                 Acknowledge.

0001e1e7 <mDebugTftp_DONE>:
   1e1e7:	46 6c 61 73 68 69 6e 67 20 63 6f 6d 70 6c 65 74     Flashing complet
   1e1f7:	65 00                                               e.

0001e1f9 <mDebugTftp_PLEN>:
   1e1f9:	50 61 63 6b 65 74 20 6c 65 6e 67 74 68 20 61 64     Packet length ad
   1e209:	6a 75 73 74 65 64 20 74 6f 20 00                    justed to .

0001e214 <mDebugTftp_WRADDR>:
   1e214:	57 72 69 74 69 6e 67 20 64 61 74 61 20 66 72 6f     Writing data fro
   1e224:	6d 20 61 64 64 72 65 73 73 20 00                    m address .

0001e22f <mDebugTftp_FULL>:
   1e22f:	46 6c 61 73 68 20 69 73 20 66 75 6c 6c 00           Flash is full.

0001e23d <mDebugTftp_NPORT>:
   1e23d:	43 68 61 6e 67 65 64 20 74 6f 20 70 6f 72 74 20     Changed to port 
	...

0001e24e <mDebugTftp_OPDATA>:
   1e24e:	44 61 74 61 20 62 6c 6f 63 6b 00                    Data block.

0001e259 <mDebugTftp_OPWRQ>:
   1e259:	57 72 69 74 65 20 72 65 71 75 65 73 74 00           Write request.

0001e267 <mDebugTftp_OPRRQ>:
   1e267:	52 65 61 64 20 72 65 71 75 65 73 74 00              Read request.

0001e274 <mDebugTftp_DLEN>:
   1e274:	20 61 6e 64 20 64 61 74 61 20 6c 65 6e 67 74 68      and data length
   1e284:	20 00                                                .

0001e286 <mDebugTftp_OPCODE>:
   1e286:	20 77 69 74 68 20 6f 70 63 6f 64 65 20 00            with opcode .

0001e294 <mDebugTftp_BLOCK>:
   1e294:	54 68 69 73 20 69 73 20 62 6c 6f 63 6b 20 00        This is block .

0001e2a3 <mDebugTftp_RADDR>:
   1e2a3:	53 65 74 20 75 70 20 72 65 74 75 72 6e 20 61 64     Set up return ad
   1e2b3:	64 72 65 73 73 00                                   dress.

0001e2b9 <mDebugTftp_OVFL>:
   1e2b9:	4f 76 65 72 66 6c 6f 77 00                          Overflow.

0001e2c2 <mDebugTftp_START>:
   1e2c2:	50 72 6f 63 65 73 73 69 6e 67 20 70 61 63 6b 65     Processing packe
   1e2d2:	74 20 6f 66 20 73 69 7a 65 20 00                    t of size .

0001e2dd <mDebugTftp_PREFIX>:
   1e2dd:	54 66 74 70 3a 20 00                                Tftp: .

0001e2e4 <mDebug_HEXPREF>:
   1e2e4:	30 78 00                                            0x.

0001e2e7 <mDebug_NEWLINE>:
   1e2e7:	0d 0a 00                                            ...

0001e2ea <__ctors_end>:
   1e2ea:	11 24       	eor	r1, r1
   1e2ec:	1f be       	out	0x3f, r1	; 63
   1e2ee:	cf ef       	ldi	r28, 0xFF	; 255
   1e2f0:	d0 e4       	ldi	r29, 0x40	; 64
   1e2f2:	de bf       	out	0x3e, r29	; 62
   1e2f4:	cd bf       	out	0x3d, r28	; 61

0001e2f6 <__do_copy_data>:
   1e2f6:	11 e0       	ldi	r17, 0x01	; 1
   1e2f8:	a0 e0       	ldi	r26, 0x00	; 0
   1e2fa:	b1 e0       	ldi	r27, 0x01	; 1
   1e2fc:	e2 ea       	ldi	r30, 0xA2	; 162
   1e2fe:	f0 ef       	ldi	r31, 0xF0	; 240
   1e300:	01 e0       	ldi	r16, 0x01	; 1
   1e302:	0b bf       	out	0x3b, r16	; 59
   1e304:	02 c0       	rjmp	.+4      	; 0x1e30a <__do_copy_data+0x14>
   1e306:	07 90       	elpm	r0, Z+
   1e308:	0d 92       	st	X+, r0
   1e30a:	ac 31       	cpi	r26, 0x1C	; 28
   1e30c:	b1 07       	cpc	r27, r17
   1e30e:	d9 f7       	brne	.-10     	; 0x1e306 <__do_copy_data+0x10>

0001e310 <__do_clear_bss>:
   1e310:	21 e0       	ldi	r18, 0x01	; 1
   1e312:	ac e1       	ldi	r26, 0x1C	; 28
   1e314:	b1 e0       	ldi	r27, 0x01	; 1
   1e316:	01 c0       	rjmp	.+2      	; 0x1e31a <.do_clear_bss_start>

0001e318 <.do_clear_bss_loop>:
   1e318:	1d 92       	st	X+, r1

0001e31a <.do_clear_bss_start>:
   1e31a:	ab 32       	cpi	r26, 0x2B	; 43
   1e31c:	b2 07       	cpc	r27, r18
   1e31e:	e1 f7       	brne	.-8      	; 0x1e318 <.do_clear_bss_loop>
   1e320:	01 d0       	rcall	.+2      	; 0x1e324 <main>
   1e322:	bd c6       	rjmp	.+3450   	; 0x1f09e <_exit>

0001e324 <main>:

int main(void)
{
	/* Disable the watchdog timer to prevent
	 * eternal reset loop of doom and despair */
	MCUSR = 0;
   1e324:	14 be       	out	0x34, r1	; 52
	wdt_disable();
   1e326:	88 e1       	ldi	r24, 0x18	; 24
   1e328:	0f b6       	in	r0, 0x3f	; 63
   1e32a:	f8 94       	cli
   1e32c:	80 93 60 00 	sts	0x0060, r24
   1e330:	10 92 60 00 	sts	0x0060, r1
   1e334:	0f be       	out	0x3f, r0	; 63
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
   1e336:	2f ef       	ldi	r18, 0xFF	; 255
   1e338:	83 ec       	ldi	r24, 0xC3	; 195
   1e33a:	99 e0       	ldi	r25, 0x09	; 9
   1e33c:	21 50       	subi	r18, 0x01	; 1
   1e33e:	80 40       	sbci	r24, 0x00	; 0
   1e340:	90 40       	sbci	r25, 0x00	; 0
   1e342:	e1 f7       	brne	.-8      	; 0x1e33c <main+0x18>
   1e344:	00 c0       	rjmp	.+0      	; 0x1e346 <main+0x22>
   1e346:	00 00       	nop
	/* This code makes the following assumptions:
	 * No interrupts will execute
	 * SP points to RAMEND
	 * r1 contains zero */
	//cli();
	asm volatile("clr __zero_reg__");
   1e348:	11 24       	eor	r1, r1
	// 0x02 -> ClkIO/8 -> 500ns period, 32ms max
	// 0X03 -> ClkIO/64 -> 4us period, 256ms max
	// 0x04 -> ClkIO/256 -> 16us period, 1024ms max
	// 0x05 -> ClkIO/1024 -> 64us period, 4096ms max
	// Set up Timer 1 as timekeeper for LED flashing
	TCCR1B = _BV(CS12) | _BV(CS10); // Same thing as TCCR1B = 0x05;
   1e34a:	85 e0       	ldi	r24, 0x05	; 5
   1e34c:	80 93 81 00 	sts	0x0081, r24

	/* Write version information in the EEPROM */
	if(eeprom_read_byte(EEPROM_MAJVER) != ARIADNE_MAJVER)
   1e350:	80 e0       	ldi	r24, 0x00	; 0
   1e352:	90 e0       	ldi	r25, 0x00	; 0
   1e354:	8e d6       	rcall	.+3356   	; 0x1f072 <__eerd_byte_m1284p>
   1e356:	88 23       	and	r24, r24
   1e358:	21 f0       	breq	.+8      	; 0x1e362 <main+0x3e>
		eeprom_write_byte(EEPROM_MAJVER, ARIADNE_MAJVER);
   1e35a:	60 e0       	ldi	r22, 0x00	; 0
   1e35c:	80 e0       	ldi	r24, 0x00	; 0
   1e35e:	90 e0       	ldi	r25, 0x00	; 0
   1e360:	90 d6       	rcall	.+3360   	; 0x1f082 <__eewr_byte_m1284p>
	if(eeprom_read_byte(EEPROM_MINVER) != ARIADNE_MINVER)
   1e362:	81 e0       	ldi	r24, 0x01	; 1
   1e364:	90 e0       	ldi	r25, 0x00	; 0
   1e366:	85 d6       	rcall	.+3338   	; 0x1f072 <__eerd_byte_m1284p>
   1e368:	84 30       	cpi	r24, 0x04	; 4
   1e36a:	21 f0       	breq	.+8      	; 0x1e374 <main+0x50>
		eeprom_write_byte(EEPROM_MINVER, ARIADNE_MINVER);
   1e36c:	64 e0       	ldi	r22, 0x04	; 4
   1e36e:	81 e0       	ldi	r24, 0x01	; 1
   1e370:	90 e0       	ldi	r25, 0x00	; 0
   1e372:	87 d6       	rcall	.+3342   	; 0x1f082 <__eewr_byte_m1284p>

	/* Initialize UART communication */
	serialInit();
   1e374:	f2 d4       	rcall	.+2532   	; 0x1ed5a <serialInit>
	DBG_MAIN(tracePGMlnMain(mDebugMain_TITLE);)
   1e376:	6b e9       	ldi	r22, 0x9B	; 155
   1e378:	70 ee       	ldi	r23, 0xE0	; 224
   1e37a:	80 ec       	ldi	r24, 0xC0	; 192
   1e37c:	90 ee       	ldi	r25, 0xE0	; 224
   1e37e:	94 d4       	rcall	.+2344   	; 0x1eca8 <tracePGMln>
		buttonInit();
	)

	/* Initalize SPI communication */
	DBG_MAIN_EX(tracePGMlnMain(mDebugMain_SPI);)
	spiInit();
   1e380:	97 d0       	rcall	.+302    	; 0x1e4b0 <spiInit>
	/* Initialize networking */
	DBG_MAIN_EX(tracePGMlnMain(mDebugMain_NET);)
	netInit();
   1e382:	a3 d0       	rcall	.+326    	; 0x1e4ca <netInit>

	/* Initialize the UDP socket for tftp */
	DBG_MAIN_EX(tracePGMlnMain(mDebugMain_TFTP);)
	tftpInit();
   1e384:	52 d3       	rcall	.+1700   	; 0x1ea2a <tftpInit>
#if defined(ANNOUNCE)
	DBG_MAIN_EX(tracePGMlnMain(mDebugMain_ANN);)
	announceInit();
#endif

	serialFlashing = FALSE;
   1e386:	10 92 29 01 	sts	0x0129, r1
	tftpFlashing = FALSE;
   1e38a:	10 92 2a 01 	sts	0x012A, r1
			if(eeprom_read_byte(EEPROM_IMG_STAT) == EEPROM_IMG_OK_VALUE) break;

			//TODO: determine the conditions for reseting server OR reseting socket
			if(tftpFlashing == TRUE) {
				// Delete first page of flash memory
				boot_page_erase(0);
   1e38e:	c3 e0       	ldi	r28, 0x03	; 3
   1e390:	c1 2c       	mov	r12, r1
   1e392:	d1 2c       	mov	r13, r1
   1e394:	76 01       	movw	r14, r12
	serialFlashing = FALSE;
	tftpFlashing = FALSE;

	for(;;) {
		// If there is no serial flashing under way, poll tftp
		if(!serialFlashing)
   1e396:	80 91 29 01 	lds	r24, 0x0129
   1e39a:	88 23       	and	r24, r24
   1e39c:	29 f0       	breq	.+10     	; 0x1e3a8 <main+0x84>
			// If tftp recieved a FINAL_ACK, break
			if(tftpPoll() == 0)
				break;

		// If there is no tftp flashing, poll serial
		if(!tftpFlashing)
   1e39e:	80 91 2a 01 	lds	r24, 0x012A
   1e3a2:	88 23       	and	r24, r24
   1e3a4:	49 f0       	breq	.+18     	; 0x1e3b8 <main+0x94>
   1e3a6:	04 c0       	rjmp	.+8      	; 0x1e3b0 <main+0x8c>

	for(;;) {
		// If there is no serial flashing under way, poll tftp
		if(!serialFlashing)
			// If tftp recieved a FINAL_ACK, break
			if(tftpPoll() == 0)
   1e3a8:	74 d3       	rcall	.+1768   	; 0x1ea92 <tftpPoll>
   1e3aa:	81 11       	cpse	r24, r1
   1e3ac:	f8 cf       	rjmp	.-16     	; 0x1e39e <main+0x7a>
   1e3ae:	1d c0       	rjmp	.+58     	; 0x1e3ea <main+0xc6>
		/* As explained above this goes out */
#if defined(ANNOUNCE)
		announcePoll();
#endif

		if(timedOut()) {
   1e3b0:	30 d5       	rcall	.+2656   	; 0x1ee12 <timedOut>
   1e3b2:	81 11       	cpse	r24, r1
   1e3b4:	05 c0       	rjmp	.+10     	; 0x1e3c0 <main+0x9c>
   1e3b6:	17 c0       	rjmp	.+46     	; 0x1e3e6 <main+0xc2>
				break;

		// If there is no tftp flashing, poll serial
		if(!tftpFlashing)
			// If flashing is done exit
			if(serialPoll() == 0)
   1e3b8:	f6 d4       	rcall	.+2540   	; 0x1eda6 <serialPoll>
   1e3ba:	81 11       	cpse	r24, r1
   1e3bc:	f9 cf       	rjmp	.-14     	; 0x1e3b0 <main+0x8c>
   1e3be:	15 c0       	rjmp	.+42     	; 0x1e3ea <main+0xc6>
#if defined(ANNOUNCE)
		announcePoll();
#endif

		if(timedOut()) {
			if(eeprom_read_byte(EEPROM_IMG_STAT) == EEPROM_IMG_OK_VALUE) break;
   1e3c0:	82 e0       	ldi	r24, 0x02	; 2
   1e3c2:	90 e0       	ldi	r25, 0x00	; 0
   1e3c4:	56 d6       	rcall	.+3244   	; 0x1f072 <__eerd_byte_m1284p>
   1e3c6:	8e 3e       	cpi	r24, 0xEE	; 238
   1e3c8:	81 f0       	breq	.+32     	; 0x1e3ea <main+0xc6>

			//TODO: determine the conditions for reseting server OR reseting socket
			if(tftpFlashing == TRUE) {
   1e3ca:	80 91 2a 01 	lds	r24, 0x012A
   1e3ce:	81 30       	cpi	r24, 0x01	; 1
   1e3d0:	51 f4       	brne	.+20     	; 0x1e3e6 <main+0xc2>
				// Delete first page of flash memory
				boot_page_erase(0);
   1e3d2:	f6 01       	movw	r30, r12
   1e3d4:	e0 92 5b 00 	sts	0x005B, r14
   1e3d8:	c0 93 57 00 	sts	0x0057, r28
   1e3dc:	e8 95       	spm
				// Reinitialize TFTP
				tftpInit();
   1e3de:	25 d3       	rcall	.+1610   	; 0x1ea2a <tftpInit>
				// Reset the timeout counter
				resetTick();
   1e3e0:	0f d5       	rcall	.+2590   	; 0x1ee00 <resetTick>
				// Unset tftp flag
				tftpFlashing = FALSE;
   1e3e2:	10 92 2a 01 	sts	0x012A, r1
			}
		}
		/* Blink the notification led */
#ifndef DISABLE_BLINK
		updateLed();
   1e3e6:	ea d4       	rcall	.+2516   	; 0x1edbc <updateLed>
#endif  //DISABLE_BLINK
	}
   1e3e8:	d6 cf       	rjmp	.-84     	; 0x1e396 <main+0x72>

	/* Exit to user application */
	DBG_MAIN(tracePGMlnMain(mDebugMain_EXIT);)
   1e3ea:	6c e8       	ldi	r22, 0x8C	; 140
   1e3ec:	70 ee       	ldi	r23, 0xE0	; 224
   1e3ee:	80 ec       	ldi	r24, 0xC0	; 192
   1e3f0:	90 ee       	ldi	r25, 0xE0	; 224
   1e3f2:	5a d4       	rcall	.+2228   	; 0x1eca8 <tracePGMln>
	asm volatile(
   1e3f4:	ee 27       	eor	r30, r30
   1e3f6:	ff 27       	eor	r31, r31
   1e3f8:	09 94       	ijmp
		"clr	r31		\n\t"
		"ijmp	\n\t"
	);
	//appStart();
	//return(0); /* never reached */
}
   1e3fa:	80 e0       	ldi	r24, 0x00	; 0
   1e3fc:	90 e0       	ldi	r25, 0x00	; 0

0001e3fe <__bad_interrupt>:
   1e3fe:	00 ce       	rjmp	.-1024   	; 0x1e000 <__vectors>

0001e400 <spiWriteReg>:
		tracenum(address);
		tracePGM(mDebugSpi_COMMA);
		tracenum(value);
	)

	SPCR = _BV(SPE) | _BV(MSTR); // Set SPI as master
   1e400:	20 e5       	ldi	r18, 0x50	; 80
   1e402:	2c bd       	out	0x2c, r18	; 44
	SS_LOW();
   1e404:	5a 98       	cbi	0x0b, 2	; 11

	SPDR = SPI_WRITE;
   1e406:	20 ef       	ldi	r18, 0xF0	; 240
   1e408:	2e bd       	out	0x2e, r18	; 46
	while(!(SPSR & _BV(SPIF)));
   1e40a:	0d b4       	in	r0, 0x2d	; 45
   1e40c:	07 fe       	sbrs	r0, 7
   1e40e:	fd cf       	rjmp	.-6      	; 0x1e40a <spiWriteReg+0xa>

	SPDR = address >> 8;
   1e410:	29 2f       	mov	r18, r25
   1e412:	33 27       	eor	r19, r19
   1e414:	2e bd       	out	0x2e, r18	; 46
	while(!(SPSR & _BV(SPIF)));
   1e416:	0d b4       	in	r0, 0x2d	; 45
   1e418:	07 fe       	sbrs	r0, 7
   1e41a:	fd cf       	rjmp	.-6      	; 0x1e416 <spiWriteReg+0x16>

	SPDR = address & 0xff;
   1e41c:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
   1e41e:	0d b4       	in	r0, 0x2d	; 45
   1e420:	07 fe       	sbrs	r0, 7
   1e422:	fd cf       	rjmp	.-6      	; 0x1e41e <spiWriteReg+0x1e>

	SPDR = value;
   1e424:	6e bd       	out	0x2e, r22	; 46
	while(!(SPSR & _BV(SPIF)));
   1e426:	0d b4       	in	r0, 0x2d	; 45
   1e428:	07 fe       	sbrs	r0, 7
   1e42a:	fd cf       	rjmp	.-6      	; 0x1e426 <spiWriteReg+0x26>

	SS_HIGH();
   1e42c:	5a 9a       	sbi	0x0b, 2	; 11
	SPCR = 0; // Turn off SPI
   1e42e:	1c bc       	out	0x2c, r1	; 44
   1e430:	08 95       	ret

0001e432 <spiWriteWord>:
}

void spiWriteWord(uint16_t address, uint16_t value)
{
   1e432:	0f 93       	push	r16
   1e434:	1f 93       	push	r17
   1e436:	cf 93       	push	r28
   1e438:	df 93       	push	r29
   1e43a:	8c 01       	movw	r16, r24
   1e43c:	eb 01       	movw	r28, r22
	// Write uint16_t to Ethernet controller
	spiWriteReg(address++, value >> 8);
   1e43e:	67 2f       	mov	r22, r23
   1e440:	77 27       	eor	r23, r23
   1e442:	de df       	rcall	.-68     	; 0x1e400 <spiWriteReg>
	spiWriteReg(address, value & 0xff);
   1e444:	6c 2f       	mov	r22, r28
   1e446:	c8 01       	movw	r24, r16
   1e448:	01 96       	adiw	r24, 0x01	; 1
}
   1e44a:	df 91       	pop	r29
   1e44c:	cf 91       	pop	r28
   1e44e:	1f 91       	pop	r17
   1e450:	0f 91       	pop	r16

void spiWriteWord(uint16_t address, uint16_t value)
{
	// Write uint16_t to Ethernet controller
	spiWriteReg(address++, value >> 8);
	spiWriteReg(address, value & 0xff);
   1e452:	d6 cf       	rjmp	.-84     	; 0x1e400 <spiWriteReg>

0001e454 <spiReadReg>:
	)
	#endif

	uint8_t returnValue;

	SPCR = _BV(SPE) | _BV(MSTR);
   1e454:	20 e5       	ldi	r18, 0x50	; 80
   1e456:	2c bd       	out	0x2c, r18	; 44
	SS_LOW();
   1e458:	5a 98       	cbi	0x0b, 2	; 11

	SPDR = SPI_READ;
   1e45a:	2f e0       	ldi	r18, 0x0F	; 15
   1e45c:	2e bd       	out	0x2e, r18	; 46
	while(!(SPSR & _BV(SPIF)));
   1e45e:	0d b4       	in	r0, 0x2d	; 45
   1e460:	07 fe       	sbrs	r0, 7
   1e462:	fd cf       	rjmp	.-6      	; 0x1e45e <spiReadReg+0xa>

	SPDR = address >> 8;
   1e464:	29 2f       	mov	r18, r25
   1e466:	33 27       	eor	r19, r19
   1e468:	2e bd       	out	0x2e, r18	; 46
	while(!(SPSR & _BV(SPIF)));
   1e46a:	0d b4       	in	r0, 0x2d	; 45
   1e46c:	07 fe       	sbrs	r0, 7
   1e46e:	fd cf       	rjmp	.-6      	; 0x1e46a <spiReadReg+0x16>

	SPDR = address & 0xff;
   1e470:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
   1e472:	0d b4       	in	r0, 0x2d	; 45
   1e474:	07 fe       	sbrs	r0, 7
   1e476:	fd cf       	rjmp	.-6      	; 0x1e472 <spiReadReg+0x1e>

	SPDR = 0;
   1e478:	1e bc       	out	0x2e, r1	; 46
	while(!(SPSR & _BV(SPIF)));
   1e47a:	0d b4       	in	r0, 0x2d	; 45
   1e47c:	07 fe       	sbrs	r0, 7
   1e47e:	fd cf       	rjmp	.-6      	; 0x1e47a <spiReadReg+0x26>

	SS_HIGH();
   1e480:	5a 9a       	sbi	0x0b, 2	; 11
	returnValue = SPDR;
   1e482:	8e b5       	in	r24, 0x2e	; 46
	SPCR = 0;
   1e484:	1c bc       	out	0x2c, r1	; 44

	return(returnValue);
}
   1e486:	08 95       	ret

0001e488 <spiReadWord>:

uint16_t spiReadWord(uint16_t address)
{
   1e488:	1f 93       	push	r17
   1e48a:	cf 93       	push	r28
   1e48c:	df 93       	push	r29
   1e48e:	ec 01       	movw	r28, r24
	// Read uint16_t from Ethernet controller
	return((spiReadReg(address) << 8) | spiReadReg(address + 1));
   1e490:	e1 df       	rcall	.-62     	; 0x1e454 <spiReadReg>
   1e492:	18 2f       	mov	r17, r24
   1e494:	ce 01       	movw	r24, r28
   1e496:	01 96       	adiw	r24, 0x01	; 1
   1e498:	dd df       	rcall	.-70     	; 0x1e454 <spiReadReg>
   1e49a:	21 2f       	mov	r18, r17
   1e49c:	30 e0       	ldi	r19, 0x00	; 0
   1e49e:	32 2f       	mov	r19, r18
   1e4a0:	22 27       	eor	r18, r18
}
   1e4a2:	a9 01       	movw	r20, r18
   1e4a4:	48 2b       	or	r20, r24
   1e4a6:	ca 01       	movw	r24, r20
   1e4a8:	df 91       	pop	r29
   1e4aa:	cf 91       	pop	r28
   1e4ac:	1f 91       	pop	r17
   1e4ae:	08 95       	ret

0001e4b0 <spiInit>:
	 * At this stage all pins are set to HIGH. This in fact DISABLES SPI for both Ethernet and SD.
	 * SS pin for ethernet is pulled low just in time for reading or writing data inside those
	 * functions. */

	/** Set SPI pins high */
	SPI_PORT = _BV(SCK) | _BV(MISO) | _BV(MOSI) | _BV(SS);
   1e4b0:	80 ef       	ldi	r24, 0xF0	; 240
   1e4b2:	85 b9       	out	0x05, r24	; 5
	/** Set SPI pins as output */
	SPI_DDR = _BV(SCK) | _BV(MOSI) | _BV(SS);
   1e4b4:	80 eb       	ldi	r24, 0xB0	; 176
   1e4b6:	84 b9       	out	0x04, r24	; 4

	#if (ETH_SS != SS)
	/** Initialize extra SS pin used in some boards (mega) */
	/** Set ethernet SS high */
	ETH_PORT |= _BV(ETH_SS);
   1e4b8:	5a 9a       	sbi	0x0b, 2	; 11
	/** Set ethernet SS as output */
	ETH_DDR |= _BV(ETH_SS);
   1e4ba:	52 9a       	sbi	0x0a, 2	; 10
	#endif

	/** Disable SD card */
	/** Set SD SS pin high */
	#ifndef NOT_SHIELD  //don't do anything to the pin if the SD hardware is not installed
	SD_PORT |= _BV(SD_SS);
   1e4bc:	2c 9a       	sbi	0x05, 4	; 5
	/** Set SD SS pin as output */
	SD_DDR |= _BV(SD_SS);
   1e4be:	24 9a       	sbi	0x04, 4	; 4

	#ifndef DISABLE_BLINK
	#if (LED != SCK)
	/** Set up pins to flash the onboard led */
	/** Set led pin to high */
	LED_PORT |= _BV(LED);
   1e4c0:	5d 9a       	sbi	0x0b, 5	; 11
	/** Set led pin as output */
	LED_DDR |= _BV(LED);
   1e4c2:	55 9a       	sbi	0x0a, 5	; 10
	#endif  //LED != SCK
	#endif  //DISABLE_BLINK

	/** Set up SPI
	 ** Set the Double SPI Speed Bit */
	SPSR = (1 << SPI2X);
   1e4c4:	81 e0       	ldi	r24, 0x01	; 1
   1e4c6:	8d bd       	out	0x2d, r24	; 45
   1e4c8:	08 95       	ret

0001e4ca <netInit>:
	0x55          // TMSR Tx Memory Size Register, 2K per socket
};


void netInit(void)
{
   1e4ca:	0f 93       	push	r16
   1e4cc:	1f 93       	push	r17
   1e4ce:	cf 93       	push	r28
   1e4d0:	df 93       	push	r29
	uint8_t i;

	/* Pull in altered network settings, if available,
	 * from AVR EEPROM (if signature bytes are set) */
	if((eeprom_read_byte(EEPROM_SIG_1) == EEPROM_SIG_1_VALUE)
   1e4d2:	83 e0       	ldi	r24, 0x03	; 3
   1e4d4:	90 e0       	ldi	r25, 0x00	; 0
   1e4d6:	cd d5       	rcall	.+2970   	; 0x1f072 <__eerd_byte_m1284p>
   1e4d8:	85 35       	cpi	r24, 0x55	; 85
   1e4da:	a9 f4       	brne	.+42     	; 0x1e506 <netInit+0x3c>
		&& (eeprom_read_byte(EEPROM_SIG_2) == EEPROM_SIG_2_VALUE)) {
   1e4dc:	84 e0       	ldi	r24, 0x04	; 4
   1e4de:	90 e0       	ldi	r25, 0x00	; 0
   1e4e0:	c8 d5       	rcall	.+2960   	; 0x1f072 <__eerd_byte_m1284p>
   1e4e2:	8a 3a       	cpi	r24, 0xAA	; 170
   1e4e4:	81 f4       	brne	.+32     	; 0x1e506 <netInit+0x3c>
   1e4e6:	01 e0       	ldi	r16, 0x01	; 1
   1e4e8:	11 e0       	ldi	r17, 0x01	; 1
   1e4ea:	c5 e0       	ldi	r28, 0x05	; 5
   1e4ec:	d0 e0       	ldi	r29, 0x00	; 0

		for(i = 0; i < EEPROM_SETTINGS_SIZE; i++)
			registerBuffer[i + 1] = eeprom_read_byte(EEPROM_DATA + i);
   1e4ee:	ce 01       	movw	r24, r28
   1e4f0:	c0 d5       	rcall	.+2944   	; 0x1f072 <__eerd_byte_m1284p>
   1e4f2:	f8 01       	movw	r30, r16
   1e4f4:	81 93       	st	Z+, r24
   1e4f6:	8f 01       	movw	r16, r30
   1e4f8:	21 96       	adiw	r28, 0x01	; 1
	/* Pull in altered network settings, if available,
	 * from AVR EEPROM (if signature bytes are set) */
	if((eeprom_read_byte(EEPROM_SIG_1) == EEPROM_SIG_1_VALUE)
		&& (eeprom_read_byte(EEPROM_SIG_2) == EEPROM_SIG_2_VALUE)) {

		for(i = 0; i < EEPROM_SETTINGS_SIZE; i++)
   1e4fa:	c7 31       	cpi	r28, 0x17	; 23
   1e4fc:	d1 05       	cpc	r29, r1
   1e4fe:	b9 f7       	brne	.-18     	; 0x1e4ee <netInit+0x24>
			registerBuffer[i + 1] = eeprom_read_byte(EEPROM_DATA + i);

		DBG_NET(tracePGMlnNet(mDebugNet_EEPROM);)
   1e500:	67 e1       	ldi	r22, 0x17	; 23
   1e502:	71 ee       	ldi	r23, 0xE1	; 225
   1e504:	02 c0       	rjmp	.+4      	; 0x1e50a <netInit+0x40>

	}
	DBG_NET(
   1e506:	65 e0       	ldi	r22, 0x05	; 5
   1e508:	71 ee       	ldi	r23, 0xE1	; 225
   1e50a:	87 e2       	ldi	r24, 0x27	; 39
   1e50c:	91 ee       	ldi	r25, 0xE1	; 225
   1e50e:	cc d3       	rcall	.+1944   	; 0x1eca8 <tracePGMln>
		else tracePGMlnNet(mDebugNet_BUILTIN);
	)


	DBG_NET(
   1e510:	6a ef       	ldi	r22, 0xFA	; 250
   1e512:	70 ee       	ldi	r23, 0xE0	; 224
   1e514:	87 e2       	ldi	r24, 0x27	; 39
   1e516:	91 ee       	ldi	r25, 0xE1	; 225
   1e518:	c7 d3       	rcall	.+1934   	; 0x1eca8 <tracePGMln>
   1e51a:	cf e0       	ldi	r28, 0x0F	; 15
   1e51c:	d1 e0       	ldi	r29, 0x01	; 1
   1e51e:	1f e0       	ldi	r17, 0x0F	; 15
   1e520:	69 91       	ld	r22, Y+
   1e522:	70 e0       	ldi	r23, 0x00	; 0
   1e524:	80 e0       	ldi	r24, 0x00	; 0
   1e526:	90 e0       	ldi	r25, 0x00	; 0
   1e528:	42 e0       	ldi	r20, 0x02	; 2
   1e52a:	ef d3       	rcall	.+2014   	; 0x1ed0a <tracehex>
   1e52c:	12 31       	cpi	r17, 0x12	; 18
   1e52e:	11 f0       	breq	.+4      	; 0x1e534 <netInit+0x6a>
   1e530:	8e e2       	ldi	r24, 0x2E	; 46
   1e532:	20 d4       	rcall	.+2112   	; 0x1ed74 <putch>
   1e534:	1f 5f       	subi	r17, 0xFF	; 255
   1e536:	13 31       	cpi	r17, 0x13	; 19
   1e538:	99 f7       	brne	.-26     	; 0x1e520 <netInit+0x56>
   1e53a:	6f ee       	ldi	r22, 0xEF	; 239
   1e53c:	70 ee       	ldi	r23, 0xE0	; 224
   1e53e:	87 e2       	ldi	r24, 0x27	; 39
   1e540:	91 ee       	ldi	r25, 0xE1	; 225
   1e542:	b2 d3       	rcall	.+1892   	; 0x1eca8 <tracePGMln>
   1e544:	c5 e0       	ldi	r28, 0x05	; 5
   1e546:	d1 e0       	ldi	r29, 0x01	; 1
   1e548:	15 e0       	ldi	r17, 0x05	; 5
   1e54a:	69 91       	ld	r22, Y+
   1e54c:	70 e0       	ldi	r23, 0x00	; 0
   1e54e:	80 e0       	ldi	r24, 0x00	; 0
   1e550:	90 e0       	ldi	r25, 0x00	; 0
   1e552:	42 e0       	ldi	r20, 0x02	; 2
   1e554:	da d3       	rcall	.+1972   	; 0x1ed0a <tracehex>
   1e556:	18 30       	cpi	r17, 0x08	; 8
   1e558:	11 f0       	breq	.+4      	; 0x1e55e <netInit+0x94>
   1e55a:	8e e2       	ldi	r24, 0x2E	; 46
   1e55c:	0b d4       	rcall	.+2070   	; 0x1ed74 <putch>
   1e55e:	1f 5f       	subi	r17, 0xFF	; 255
   1e560:	19 30       	cpi	r17, 0x09	; 9
   1e562:	99 f7       	brne	.-26     	; 0x1e54a <netInit+0x80>
   1e564:	64 ee       	ldi	r22, 0xE4	; 228
   1e566:	70 ee       	ldi	r23, 0xE0	; 224
   1e568:	87 e2       	ldi	r24, 0x27	; 39
   1e56a:	91 ee       	ldi	r25, 0xE1	; 225
   1e56c:	9d d3       	rcall	.+1850   	; 0x1eca8 <tracePGMln>
   1e56e:	c1 e0       	ldi	r28, 0x01	; 1
   1e570:	d1 e0       	ldi	r29, 0x01	; 1
   1e572:	01 e0       	ldi	r16, 0x01	; 1
   1e574:	69 91       	ld	r22, Y+
   1e576:	70 e0       	ldi	r23, 0x00	; 0
   1e578:	80 e0       	ldi	r24, 0x00	; 0
   1e57a:	90 e0       	ldi	r25, 0x00	; 0
   1e57c:	42 e0       	ldi	r20, 0x02	; 2
   1e57e:	c5 d3       	rcall	.+1930   	; 0x1ed0a <tracehex>
   1e580:	04 30       	cpi	r16, 0x04	; 4
   1e582:	11 f0       	breq	.+4      	; 0x1e588 <netInit+0xbe>
   1e584:	8e e2       	ldi	r24, 0x2E	; 46
   1e586:	f6 d3       	rcall	.+2028   	; 0x1ed74 <putch>
   1e588:	0f 5f       	subi	r16, 0xFF	; 255
   1e58a:	05 30       	cpi	r16, 0x05	; 5
   1e58c:	99 f7       	brne	.-26     	; 0x1e574 <netInit+0xaa>
   1e58e:	69 ed       	ldi	r22, 0xD9	; 217
   1e590:	70 ee       	ldi	r23, 0xE0	; 224
   1e592:	87 e2       	ldi	r24, 0x27	; 39
   1e594:	91 ee       	ldi	r25, 0xE1	; 225
   1e596:	88 d3       	rcall	.+1808   	; 0x1eca8 <tracePGMln>
   1e598:	c9 e0       	ldi	r28, 0x09	; 9
   1e59a:	d1 e0       	ldi	r29, 0x01	; 1
   1e59c:	69 91       	ld	r22, Y+
   1e59e:	70 e0       	ldi	r23, 0x00	; 0
   1e5a0:	80 e0       	ldi	r24, 0x00	; 0
   1e5a2:	90 e0       	ldi	r25, 0x00	; 0
   1e5a4:	42 e0       	ldi	r20, 0x02	; 2
   1e5a6:	b1 d3       	rcall	.+1890   	; 0x1ed0a <tracehex>
   1e5a8:	1e 30       	cpi	r17, 0x0E	; 14
   1e5aa:	11 f0       	breq	.+4      	; 0x1e5b0 <netInit+0xe6>
   1e5ac:	8e e2       	ldi	r24, 0x2E	; 46
   1e5ae:	e2 d3       	rcall	.+1988   	; 0x1ed74 <putch>
   1e5b0:	1f 5f       	subi	r17, 0xFF	; 255
   1e5b2:	1f 30       	cpi	r17, 0x0F	; 15
   1e5b4:	99 f7       	brne	.-26     	; 0x1e59c <netInit+0xd2>
   1e5b6:	00 e0       	ldi	r16, 0x00	; 0
   1e5b8:	11 e0       	ldi	r17, 0x01	; 1
   1e5ba:	c0 e0       	ldi	r28, 0x00	; 0
   1e5bc:	d0 e0       	ldi	r29, 0x00	; 0
		}
	)

	/** Configure Wiznet chip. Network settings */
	for(i = 0; i < REGISTER_BLOCK_SIZE; i++)
		spiWriteReg(i, registerBuffer[i]);
   1e5be:	f8 01       	movw	r30, r16
   1e5c0:	61 91       	ld	r22, Z+
   1e5c2:	8f 01       	movw	r16, r30
   1e5c4:	ce 01       	movw	r24, r28
   1e5c6:	1c df       	rcall	.-456    	; 0x1e400 <spiWriteReg>
   1e5c8:	21 96       	adiw	r28, 0x01	; 1
			if(i != 14) putch(0x2E);
		}
	)

	/** Configure Wiznet chip. Network settings */
	for(i = 0; i < REGISTER_BLOCK_SIZE; i++)
   1e5ca:	cc 31       	cpi	r28, 0x1C	; 28
   1e5cc:	d1 05       	cpc	r29, r1
   1e5ce:	b9 f7       	brne	.-18     	; 0x1e5be <netInit+0xf4>
		spiWriteReg(i, registerBuffer[i]);

	DBG_NET(tracePGMlnNet(mDebugNet_DONE);)
   1e5d0:	67 ec       	ldi	r22, 0xC7	; 199
   1e5d2:	70 ee       	ldi	r23, 0xE0	; 224
   1e5d4:	87 e2       	ldi	r24, 0x27	; 39
   1e5d6:	91 ee       	ldi	r25, 0xE1	; 225
}
   1e5d8:	df 91       	pop	r29
   1e5da:	cf 91       	pop	r28
   1e5dc:	1f 91       	pop	r17
   1e5de:	0f 91       	pop	r16

	/** Configure Wiznet chip. Network settings */
	for(i = 0; i < REGISTER_BLOCK_SIZE; i++)
		spiWriteReg(i, registerBuffer[i]);

	DBG_NET(tracePGMlnNet(mDebugNet_DONE);)
   1e5e0:	63 c3       	rjmp	.+1734   	; 0x1eca8 <tracePGMln>

0001e5e2 <sockInit>:

uint16_t lastPacket = 0, highPacket = 0;


static void sockInit(uint16_t port)
{
   1e5e2:	cf 93       	push	r28
   1e5e4:	df 93       	push	r29
   1e5e6:	ec 01       	movw	r28, r24
	DBG_TFTP(
   1e5e8:	68 e6       	ldi	r22, 0x68	; 104
   1e5ea:	71 ee       	ldi	r23, 0xE1	; 225
   1e5ec:	8d ed       	ldi	r24, 0xDD	; 221
   1e5ee:	92 ee       	ldi	r25, 0xE2	; 226
   1e5f0:	5b d3       	rcall	.+1718   	; 0x1eca8 <tracePGMln>
   1e5f2:	be 01       	movw	r22, r28
   1e5f4:	80 e0       	ldi	r24, 0x00	; 0
   1e5f6:	90 e0       	ldi	r25, 0x00	; 0
   1e5f8:	44 e0       	ldi	r20, 0x04	; 4
   1e5fa:	87 d3       	rcall	.+1806   	; 0x1ed0a <tracehex>
		tracePGMlnTftp(mDebugTftp_SOCK);
		tracenum(port);
	)

	spiWriteReg(REG_S3_CR, CR_CLOSE);
   1e5fc:	60 e1       	ldi	r22, 0x10	; 16
   1e5fe:	81 e0       	ldi	r24, 0x01	; 1
   1e600:	97 e0       	ldi	r25, 0x07	; 7
   1e602:	fe de       	rcall	.-516    	; 0x1e400 <spiWriteReg>

	do {
		// Write TFTP Port
		spiWriteWord(REG_S3_PORT0, port);
   1e604:	be 01       	movw	r22, r28
   1e606:	84 e0       	ldi	r24, 0x04	; 4
   1e608:	97 e0       	ldi	r25, 0x07	; 7
   1e60a:	13 df       	rcall	.-474    	; 0x1e432 <spiWriteWord>
		// Write mode
		spiWriteReg(REG_S3_MR, MR_UDP);
   1e60c:	62 e0       	ldi	r22, 0x02	; 2
   1e60e:	80 e0       	ldi	r24, 0x00	; 0
   1e610:	97 e0       	ldi	r25, 0x07	; 7
   1e612:	f6 de       	rcall	.-532    	; 0x1e400 <spiWriteReg>
		// Open Socket
		spiWriteReg(REG_S3_CR, CR_OPEN);
   1e614:	61 e0       	ldi	r22, 0x01	; 1
   1e616:	81 e0       	ldi	r24, 0x01	; 1
   1e618:	97 e0       	ldi	r25, 0x07	; 7
   1e61a:	f2 de       	rcall	.-540    	; 0x1e400 <spiWriteReg>

		// Read Status
		if(spiReadReg(REG_S3_SR) != SOCK_UDP)
   1e61c:	83 e0       	ldi	r24, 0x03	; 3
   1e61e:	97 e0       	ldi	r25, 0x07	; 7
   1e620:	19 df       	rcall	.-462    	; 0x1e454 <spiReadReg>
   1e622:	82 32       	cpi	r24, 0x22	; 34
   1e624:	21 f0       	breq	.+8      	; 0x1e62e <sockInit+0x4c>
			// Close Socket if it wasn't initialized correctly
			spiWriteReg(REG_S3_CR, CR_CLOSE);
   1e626:	60 e1       	ldi	r22, 0x10	; 16
   1e628:	81 e0       	ldi	r24, 0x01	; 1
   1e62a:	97 e0       	ldi	r25, 0x07	; 7
   1e62c:	e9 de       	rcall	.-558    	; 0x1e400 <spiWriteReg>

		// If socket correctly opened continue
	} while(spiReadReg(REG_S3_SR) != SOCK_UDP);
   1e62e:	83 e0       	ldi	r24, 0x03	; 3
   1e630:	97 e0       	ldi	r25, 0x07	; 7
   1e632:	10 df       	rcall	.-480    	; 0x1e454 <spiReadReg>
   1e634:	82 32       	cpi	r24, 0x22	; 34
   1e636:	31 f7       	brne	.-52     	; 0x1e604 <sockInit+0x22>
}
   1e638:	df 91       	pop	r29
   1e63a:	cf 91       	pop	r28
   1e63c:	08 95       	ret

0001e63e <processPacket>:
#if (DEBUG_TFTP > 0)
static uint8_t processPacket(uint16_t packetSize)
#else
static uint8_t processPacket(void)
#endif
{
   1e63e:	3f 92       	push	r3
   1e640:	4f 92       	push	r4
   1e642:	5f 92       	push	r5
   1e644:	6f 92       	push	r6
   1e646:	7f 92       	push	r7
   1e648:	8f 92       	push	r8
   1e64a:	9f 92       	push	r9
   1e64c:	af 92       	push	r10
   1e64e:	bf 92       	push	r11
   1e650:	cf 92       	push	r12
   1e652:	df 92       	push	r13
   1e654:	ef 92       	push	r14
   1e656:	ff 92       	push	r15
   1e658:	0f 93       	push	r16
   1e65a:	1f 93       	push	r17
   1e65c:	cf 93       	push	r28
   1e65e:	df 93       	push	r29
   1e660:	cd b7       	in	r28, 0x3d	; 61
   1e662:	de b7       	in	r29, 0x3e	; 62
   1e664:	cc 50       	subi	r28, 0x0C	; 12
   1e666:	d2 40       	sbci	r29, 0x02	; 2
   1e668:	de bf       	out	0x3e, r29	; 62
   1e66a:	cd bf       	out	0x3d, r28	; 61
   1e66c:	8c 01       	movw	r16, r24
	address_t writeAddr;
	// Transfer entire packet to RAM
	uint8_t* bufPtr = buffer;
	uint16_t count;

	DBG_TFTP(
   1e66e:	62 ec       	ldi	r22, 0xC2	; 194
   1e670:	72 ee       	ldi	r23, 0xE2	; 226
   1e672:	8d ed       	ldi	r24, 0xDD	; 221
   1e674:	92 ee       	ldi	r25, 0xE2	; 226
   1e676:	18 d3       	rcall	.+1584   	; 0x1eca8 <tracePGMln>
   1e678:	b8 01       	movw	r22, r16
   1e67a:	80 e0       	ldi	r24, 0x00	; 0
   1e67c:	90 e0       	ldi	r25, 0x00	; 0
   1e67e:	44 e0       	ldi	r20, 0x04	; 4
   1e680:	44 d3       	rcall	.+1672   	; 0x1ed0a <tracehex>
   1e682:	01 15       	cp	r16, r1
   1e684:	18 40       	sbci	r17, 0x08	; 8
   1e686:	28 f0       	brcs	.+10     	; 0x1e692 <processPacket+0x54>
   1e688:	69 eb       	ldi	r22, 0xB9	; 185
   1e68a:	72 ee       	ldi	r23, 0xE2	; 226
   1e68c:	8d ed       	ldi	r24, 0xDD	; 221
   1e68e:	92 ee       	ldi	r25, 0xE2	; 226
   1e690:	0b d3       	rcall	.+1558   	; 0x1eca8 <tracePGMln>

		DBG_BTN(button();)
	)

	// Read data from chip to buffer
	readPointer = spiReadWord(REG_S3_RX_RD0);
   1e692:	88 e2       	ldi	r24, 0x28	; 40
   1e694:	97 e0       	ldi	r25, 0x07	; 7
   1e696:	f8 de       	rcall	.-528    	; 0x1e488 <spiReadWord>
	DBG_TFTP_EX(
		tracePGMlnTftp(mDebugTftp_RPTR);
		tracenum(readPointer);
	)

	if(readPointer == 0) readPointer += S3_RX_START;
   1e698:	00 97       	sbiw	r24, 0x00	; 0
   1e69a:	11 f4       	brne	.+4      	; 0x1e6a0 <processPacket+0x62>
   1e69c:	80 e0       	ldi	r24, 0x00	; 0
   1e69e:	98 e7       	ldi	r25, 0x78	; 120
   1e6a0:	8e 01       	movw	r16, r28
   1e6a2:	0f 5f       	subi	r16, 0xFF	; 255
   1e6a4:	1f 4f       	sbci	r17, 0xFF	; 255
   1e6a6:	6e 01       	movw	r12, r28
   1e6a8:	e3 ef       	ldi	r30, 0xF3	; 243
   1e6aa:	ce 1a       	sub	r12, r30
   1e6ac:	ed ef       	ldi	r30, 0xFD	; 253
   1e6ae:	de 0a       	sbc	r13, r30

	for(count = TFTP_PACKET_MAX_SIZE; count--;) {
   1e6b0:	0c 15       	cp	r16, r12
   1e6b2:	1d 05       	cpc	r17, r13
   1e6b4:	89 f0       	breq	.+34     	; 0x1e6d8 <processPacket+0x9a>
				tracePGMlnTftp(mDebugTftp_RPOS);
				tracenum(readPointer);
			}
		)

		*bufPtr++ = spiReadReg(readPointer++);
   1e6b6:	7c 01       	movw	r14, r24
   1e6b8:	ff ef       	ldi	r31, 0xFF	; 255
   1e6ba:	ef 1a       	sub	r14, r31
   1e6bc:	ff 0a       	sbc	r15, r31
   1e6be:	ca de       	rcall	.-620    	; 0x1e454 <spiReadReg>
   1e6c0:	f8 01       	movw	r30, r16
   1e6c2:	81 93       	st	Z+, r24
   1e6c4:	8f 01       	movw	r16, r30

		if(readPointer == S3_RX_END) readPointer = S3_RX_START;
   1e6c6:	e1 14       	cp	r14, r1
   1e6c8:	f0 e8       	ldi	r31, 0x80	; 128
   1e6ca:	ff 06       	cpc	r15, r31
   1e6cc:	19 f4       	brne	.+6      	; 0x1e6d4 <processPacket+0x96>
   1e6ce:	e1 2c       	mov	r14, r1
   1e6d0:	78 e7       	ldi	r23, 0x78	; 120
   1e6d2:	f7 2e       	mov	r15, r23
   1e6d4:	c7 01       	movw	r24, r14
   1e6d6:	ec cf       	rjmp	.-40     	; 0x1e6b0 <processPacket+0x72>
	}

	spiWriteWord(REG_S3_RX_RD0, readPointer);     // Write back new pointer
   1e6d8:	bc 01       	movw	r22, r24
   1e6da:	88 e2       	ldi	r24, 0x28	; 40
   1e6dc:	97 e0       	ldi	r25, 0x07	; 7
   1e6de:	a9 de       	rcall	.-686    	; 0x1e432 <spiWriteWord>
	spiWriteReg(REG_S3_CR, CR_RECV);
   1e6e0:	60 e4       	ldi	r22, 0x40	; 64
   1e6e2:	81 e0       	ldi	r24, 0x01	; 1
   1e6e4:	97 e0       	ldi	r25, 0x07	; 7
   1e6e6:	8c de       	rcall	.-744    	; 0x1e400 <spiWriteReg>

	while(spiReadReg(REG_S3_CR));
   1e6e8:	81 e0       	ldi	r24, 0x01	; 1
   1e6ea:	97 e0       	ldi	r25, 0x07	; 7
   1e6ec:	b3 de       	rcall	.-666    	; 0x1e454 <spiReadReg>
   1e6ee:	81 11       	cpse	r24, r1
   1e6f0:	fb cf       	rjmp	.-10     	; 0x1e6e8 <processPacket+0xaa>
   1e6f2:	ce 01       	movw	r24, r28
   1e6f4:	01 96       	adiw	r24, 0x01	; 1
   1e6f6:	7c 01       	movw	r14, r24
   1e6f8:	0c e0       	ldi	r16, 0x0C	; 12
   1e6fa:	17 e0       	ldi	r17, 0x07	; 7
	)

	// Set up return IP address and port
	uint8_t i;

	for(i = 0; i < 6; i++) spiWriteReg(REG_S3_DIPR0 + i, buffer[i]);
   1e6fc:	f7 01       	movw	r30, r14
   1e6fe:	61 91       	ld	r22, Z+
   1e700:	7f 01       	movw	r14, r30
   1e702:	c8 01       	movw	r24, r16
   1e704:	7d de       	rcall	.-774    	; 0x1e400 <spiWriteReg>
   1e706:	0f 5f       	subi	r16, 0xFF	; 255
   1e708:	1f 4f       	sbci	r17, 0xFF	; 255
   1e70a:	02 31       	cpi	r16, 0x12	; 18
   1e70c:	f7 e0       	ldi	r31, 0x07	; 7
   1e70e:	1f 07       	cpc	r17, r31
   1e710:	a9 f7       	brne	.-22     	; 0x1e6fc <processPacket+0xbe>

	DBG_TFTP(tracePGMlnTftp(mDebugTftp_RADDR);)
   1e712:	63 ea       	ldi	r22, 0xA3	; 163
   1e714:	72 ee       	ldi	r23, 0xE2	; 226
   1e716:	8d ed       	ldi	r24, 0xDD	; 221
   1e718:	92 ee       	ldi	r25, 0xE2	; 226
   1e71a:	c6 d2       	rcall	.+1420   	; 0x1eca8 <tracePGMln>

	// Parse packet
	uint16_t tftpDataLen = (buffer[6] << 8) + buffer[7];
   1e71c:	af 80       	ldd	r10, Y+7	; 0x07
   1e71e:	b1 2c       	mov	r11, r1
   1e720:	ba 2c       	mov	r11, r10
   1e722:	aa 24       	eor	r10, r10
   1e724:	88 85       	ldd	r24, Y+8	; 0x08
   1e726:	a8 0e       	add	r10, r24
   1e728:	b1 1c       	adc	r11, r1
	uint16_t tftpOpcode  = (buffer[8] << 8) + buffer[9];
   1e72a:	09 85       	ldd	r16, Y+9	; 0x09
   1e72c:	10 e0       	ldi	r17, 0x00	; 0
   1e72e:	10 2f       	mov	r17, r16
   1e730:	00 27       	eor	r16, r16
   1e732:	8a 85       	ldd	r24, Y+10	; 0x0a
   1e734:	08 0f       	add	r16, r24
   1e736:	11 1d       	adc	r17, r1
	uint16_t tftpBlock   = (buffer[10] << 8) + buffer[11];
   1e738:	eb 84       	ldd	r14, Y+11	; 0x0b
   1e73a:	f1 2c       	mov	r15, r1
   1e73c:	fe 2c       	mov	r15, r14
   1e73e:	ee 24       	eor	r14, r14
   1e740:	8c 85       	ldd	r24, Y+12	; 0x0c
   1e742:	e8 0e       	add	r14, r24
   1e744:	f1 1c       	adc	r15, r1

	DBG_TFTP(
   1e746:	64 e9       	ldi	r22, 0x94	; 148
   1e748:	72 ee       	ldi	r23, 0xE2	; 226
   1e74a:	8d ed       	ldi	r24, 0xDD	; 221
   1e74c:	92 ee       	ldi	r25, 0xE2	; 226
   1e74e:	ac d2       	rcall	.+1368   	; 0x1eca8 <tracePGMln>
   1e750:	b7 01       	movw	r22, r14
   1e752:	80 e0       	ldi	r24, 0x00	; 0
   1e754:	90 e0       	ldi	r25, 0x00	; 0
   1e756:	44 e0       	ldi	r20, 0x04	; 4
   1e758:	d8 d2       	rcall	.+1456   	; 0x1ed0a <tracehex>
   1e75a:	86 e8       	ldi	r24, 0x86	; 134
   1e75c:	92 ee       	ldi	r25, 0xE2	; 226
   1e75e:	80 d2       	rcall	.+1280   	; 0x1ec60 <tracePGM>
   1e760:	b8 01       	movw	r22, r16
   1e762:	80 e0       	ldi	r24, 0x00	; 0
   1e764:	90 e0       	ldi	r25, 0x00	; 0
   1e766:	44 e0       	ldi	r20, 0x04	; 4
   1e768:	d0 d2       	rcall	.+1440   	; 0x1ed0a <tracehex>
   1e76a:	84 e7       	ldi	r24, 0x74	; 116
   1e76c:	92 ee       	ldi	r25, 0xE2	; 226
   1e76e:	78 d2       	rcall	.+1264   	; 0x1ec60 <tracePGM>
   1e770:	65 01       	movw	r12, r10
   1e772:	24 e0       	ldi	r18, 0x04	; 4
   1e774:	c2 1a       	sub	r12, r18
   1e776:	d1 08       	sbc	r13, r1
   1e778:	26 01       	movw	r4, r12
   1e77a:	61 2c       	mov	r6, r1
   1e77c:	71 2c       	mov	r7, r1
   1e77e:	44 e0       	ldi	r20, 0x04	; 4
   1e780:	c3 01       	movw	r24, r6
   1e782:	b2 01       	movw	r22, r4
   1e784:	c2 d2       	rcall	.+1412   	; 0x1ed0a <tracehex>
		tracenum(tftpOpcode);
		tracePGM(mDebugTftp_DLEN);
		tracenum(tftpDataLen - (TFTP_OPCODE_SIZE + TFTP_BLOCKNO_SIZE));
	)

	if((tftpOpcode == TFTP_OPCODE_DATA)
   1e786:	03 30       	cpi	r16, 0x03	; 3
   1e788:	11 05       	cpc	r17, r1
   1e78a:	91 f4       	brne	.+36     	; 0x1e7b0 <processPacket+0x172>
		&& ((tftpBlock > MAX_ADDR / 0x200) || (tftpBlock < highPacket) || (tftpBlock > highPacket + 1)))
   1e78c:	89 ef       	ldi	r24, 0xF9	; 249
   1e78e:	e8 16       	cp	r14, r24
   1e790:	f1 04       	cpc	r15, r1
   1e792:	60 f4       	brcc	.+24     	; 0x1e7ac <processPacket+0x16e>
   1e794:	80 91 1c 01 	lds	r24, 0x011C
   1e798:	90 91 1d 01 	lds	r25, 0x011D
   1e79c:	e8 16       	cp	r14, r24
   1e79e:	f9 06       	cpc	r15, r25
   1e7a0:	28 f0       	brcs	.+10     	; 0x1e7ac <processPacket+0x16e>
   1e7a2:	01 96       	adiw	r24, 0x01	; 1
   1e7a4:	8e 15       	cp	r24, r14
   1e7a6:	9f 05       	cpc	r25, r15
   1e7a8:	08 f0       	brcs	.+2      	; 0x1e7ac <processPacket+0x16e>
   1e7aa:	48 c0       	rjmp	.+144    	; 0x1e83c <processPacket+0x1fe>
		tftpOpcode = TFTP_OPCODE_UKN;
   1e7ac:	00 e0       	ldi	r16, 0x00	; 0
   1e7ae:	10 e0       	ldi	r17, 0x00	; 0

	if(tftpDataLen > (0x200 + TFTP_OPCODE_SIZE + TFTP_BLOCKNO_SIZE))
   1e7b0:	95 e0       	ldi	r25, 0x05	; 5
   1e7b2:	a9 16       	cp	r10, r25
   1e7b4:	92 e0       	ldi	r25, 0x02	; 2
   1e7b6:	b9 06       	cpc	r11, r25
   1e7b8:	08 f0       	brcs	.+2      	; 0x1e7bc <processPacket+0x17e>
   1e7ba:	0e c1       	rjmp	.+540    	; 0x1e9d8 <processPacket+0x39a>

	uint8_t returnCode = ERROR_UNKNOWN;
	uint16_t packetLength;


	switch(tftpOpcode) {
   1e7bc:	03 30       	cpi	r16, 0x03	; 3
   1e7be:	11 05       	cpc	r17, r1
   1e7c0:	09 f4       	brne	.+2      	; 0x1e7c4 <processPacket+0x186>
   1e7c2:	42 c0       	rjmp	.+132    	; 0x1e848 <processPacket+0x20a>
   1e7c4:	68 f5       	brcc	.+90     	; 0x1e820 <processPacket+0x1e2>
   1e7c6:	01 30       	cpi	r16, 0x01	; 1
   1e7c8:	11 05       	cpc	r17, r1
   1e7ca:	a9 f1       	breq	.+106    	; 0x1e836 <processPacket+0x1f8>
   1e7cc:	02 30       	cpi	r16, 0x02	; 2
   1e7ce:	11 05       	cpc	r17, r1
   1e7d0:	09 f0       	breq	.+2      	; 0x1e7d4 <processPacket+0x196>
   1e7d2:	04 c1       	rjmp	.+520    	; 0x1e9dc <processPacket+0x39e>
			DBG_TFTP(tracePGMlnTftp(mDebugTftp_OPRRQ);)
			break;

		case TFTP_OPCODE_WRQ: // Write request
			// Valid WRQ -> reset timer
			resetTick();
   1e7d4:	15 d3       	rcall	.+1578   	; 0x1ee00 <resetTick>

			DBG_TFTP(tracePGMlnTftp(mDebugTftp_OPWRQ);)
   1e7d6:	69 e5       	ldi	r22, 0x59	; 89
   1e7d8:	72 ee       	ldi	r23, 0xE2	; 226
   1e7da:	8d ed       	ldi	r24, 0xDD	; 221
   1e7dc:	92 ee       	ldi	r25, 0xE2	; 226
   1e7de:	64 d2       	rcall	.+1224   	; 0x1eca8 <tracePGMln>

			// Flagging image as invalid since the flashing process has started
			eeprom_write_byte(EEPROM_IMG_STAT, EEPROM_IMG_BAD_VALUE);
   1e7e0:	6f ef       	ldi	r22, 0xFF	; 255
   1e7e2:	82 e0       	ldi	r24, 0x02	; 2
   1e7e4:	90 e0       	ldi	r25, 0x00	; 0
   1e7e6:	4d d4       	rcall	.+2202   	; 0x1f082 <__eewr_byte_m1284p>

#if defined(RANDOM_TFTP_DATA_PORT)
			sockInit((buffer[4] << 8) | ~buffer[5]); // Generate a 'random' TID (RFC1350)
#else
			sockInit(tftpTransferPort);
   1e7e8:	80 91 27 01 	lds	r24, 0x0127
   1e7ec:	90 91 28 01 	lds	r25, 0x0128
   1e7f0:	f8 de       	rcall	.-528    	; 0x1e5e2 <sockInit>
#endif

			DBG_TFTP(
   1e7f2:	6d e3       	ldi	r22, 0x3D	; 61
   1e7f4:	72 ee       	ldi	r23, 0xE2	; 226
   1e7f6:	8d ed       	ldi	r24, 0xDD	; 221
   1e7f8:	92 ee       	ldi	r25, 0xE2	; 226
   1e7fa:	56 d2       	rcall	.+1196   	; 0x1eca8 <tracePGMln>
   1e7fc:	60 91 27 01 	lds	r22, 0x0127
   1e800:	70 91 28 01 	lds	r23, 0x0128
   1e804:	80 e0       	ldi	r24, 0x00	; 0
   1e806:	90 e0       	ldi	r25, 0x00	; 0
   1e808:	44 e0       	ldi	r20, 0x04	; 4
   1e80a:	7f d2       	rcall	.+1278   	; 0x1ed0a <tracehex>
#else
				tracenum(tftpTransferPort);
#endif
			)

			lastPacket = highPacket = 0;
   1e80c:	10 92 1d 01 	sts	0x011D, r1
   1e810:	10 92 1c 01 	sts	0x011C, r1
   1e814:	10 92 1f 01 	sts	0x011F, r1
   1e818:	10 92 1e 01 	sts	0x011E, r1
			returnCode = ACK; // Send back acknowledge for packet 0
   1e81c:	12 e0       	ldi	r17, 0x02	; 2
			break;
   1e81e:	ee c0       	rjmp	.+476    	; 0x1e9fc <processPacket+0x3be>

	uint8_t returnCode = ERROR_UNKNOWN;
	uint16_t packetLength;


	switch(tftpOpcode) {
   1e820:	04 30       	cpi	r16, 0x04	; 4
   1e822:	11 05       	cpc	r17, r1
   1e824:	09 f4       	brne	.+2      	; 0x1e828 <processPacket+0x1ea>
   1e826:	d1 c0       	rjmp	.+418    	; 0x1e9ca <processPacket+0x38c>
   1e828:	05 30       	cpi	r16, 0x05	; 5
   1e82a:	11 05       	cpc	r17, r1
   1e82c:	09 f0       	breq	.+2      	; 0x1e830 <processPacket+0x1f2>
   1e82e:	d6 c0       	rjmp	.+428    	; 0x1e9dc <processPacket+0x39e>
			break;

		// Error signal
		case TFTP_OPCODE_ERROR:

			DBG_TFTP(tracePGMlnTftp(mDebugTftp_OPERR);)
   1e830:	65 ed       	ldi	r22, 0xD5	; 213
   1e832:	71 ee       	ldi	r23, 0xE1	; 225
   1e834:	cc c0       	rjmp	.+408    	; 0x1e9ce <processPacket+0x390>


	switch(tftpOpcode) {

		case TFTP_OPCODE_RRQ: // Read request
			DBG_TFTP(tracePGMlnTftp(mDebugTftp_OPRRQ);)
   1e836:	67 e6       	ldi	r22, 0x67	; 103
   1e838:	72 ee       	ldi	r23, 0xE2	; 226
   1e83a:	c9 c0       	rjmp	.+402    	; 0x1e9ce <processPacket+0x390>

	if((tftpOpcode == TFTP_OPCODE_DATA)
		&& ((tftpBlock > MAX_ADDR / 0x200) || (tftpBlock < highPacket) || (tftpBlock > highPacket + 1)))
		tftpOpcode = TFTP_OPCODE_UKN;

	if(tftpDataLen > (0x200 + TFTP_OPCODE_SIZE + TFTP_BLOCKNO_SIZE))
   1e83c:	e5 e0       	ldi	r30, 0x05	; 5
   1e83e:	ae 16       	cp	r10, r30
   1e840:	e2 e0       	ldi	r30, 0x02	; 2
   1e842:	be 06       	cpc	r11, r30
   1e844:	08 f0       	brcs	.+2      	; 0x1e848 <processPacket+0x20a>
   1e846:	c8 c0       	rjmp	.+400    	; 0x1e9d8 <processPacket+0x39a>
			returnCode = ACK; // Send back acknowledge for packet 0
			break;

		case TFTP_OPCODE_DATA:
			// Valid Data Packet -> reset timer
			resetTick();
   1e848:	db d2       	rcall	.+1462   	; 0x1ee00 <resetTick>

			DBG_TFTP(tracePGMlnTftp(mDebugTftp_OPDATA);)
   1e84a:	6e e4       	ldi	r22, 0x4E	; 78
   1e84c:	72 ee       	ldi	r23, 0xE2	; 226
   1e84e:	8d ed       	ldi	r24, 0xDD	; 221
   1e850:	92 ee       	ldi	r25, 0xE2	; 226
   1e852:	2a d2       	rcall	.+1108   	; 0x1eca8 <tracePGMln>

			packetLength = tftpDataLen - (TFTP_OPCODE_SIZE + TFTP_BLOCKNO_SIZE);
			lastPacket = tftpBlock;
   1e854:	f0 92 1f 01 	sts	0x011F, r15
   1e858:	e0 92 1e 01 	sts	0x011E, r14
#if defined(RAMPZ)
			writeAddr = (((address_t)((tftpBlock - 1)/0x80) << 16) | ((address_t)((tftpBlock - 1)%0x80) << 9));
   1e85c:	e1 e0       	ldi	r30, 0x01	; 1
   1e85e:	ee 1a       	sub	r14, r30
   1e860:	f1 08       	sbc	r15, r1
   1e862:	47 01       	movw	r8, r14
   1e864:	a1 2c       	mov	r10, r1
   1e866:	b1 2c       	mov	r11, r1
   1e868:	99 e0       	ldi	r25, 0x09	; 9
   1e86a:	88 0c       	add	r8, r8
   1e86c:	99 1c       	adc	r9, r9
   1e86e:	aa 1c       	adc	r10, r10
   1e870:	bb 1c       	adc	r11, r11
   1e872:	9a 95       	dec	r25
   1e874:	d1 f7       	brne	.-12     	; 0x1e86a <processPacket+0x22c>
   1e876:	aa 24       	eor	r10, r10
   1e878:	bb 24       	eor	r11, r11
   1e87a:	ee 0c       	add	r14, r14
   1e87c:	ef 2c       	mov	r14, r15
   1e87e:	ee 1c       	adc	r14, r14
   1e880:	ff 08       	sbc	r15, r15
   1e882:	f1 94       	neg	r15
   1e884:	c7 01       	movw	r24, r14
   1e886:	a0 e0       	ldi	r26, 0x00	; 0
   1e888:	b0 e0       	ldi	r27, 0x00	; 0
   1e88a:	dc 01       	movw	r26, r24
   1e88c:	99 27       	eor	r25, r25
   1e88e:	88 27       	eor	r24, r24
   1e890:	88 2a       	or	r8, r24
   1e892:	99 2a       	or	r9, r25
   1e894:	aa 2a       	or	r10, r26
   1e896:	bb 2a       	or	r11, r27
#else
			writeAddr = (address_t)((address_t)(tftpBlock - 1) << 9); // Flash write address for this block
#endif

			if((writeAddr + packetLength) > MAX_ADDR) {
   1e898:	48 0c       	add	r4, r8
   1e89a:	59 1c       	adc	r5, r9
   1e89c:	6a 1c       	adc	r6, r10
   1e89e:	7b 1c       	adc	r7, r11
   1e8a0:	f1 e0       	ldi	r31, 0x01	; 1
   1e8a2:	4f 16       	cp	r4, r31
   1e8a4:	f0 ef       	ldi	r31, 0xF0	; 240
   1e8a6:	5f 06       	cpc	r5, r31
   1e8a8:	f1 e0       	ldi	r31, 0x01	; 1
   1e8aa:	6f 06       	cpc	r6, r31
   1e8ac:	71 04       	cpc	r7, r1
   1e8ae:	38 f0       	brcs	.+14     	; 0x1e8be <processPacket+0x280>
				// Flash is full - abort with an error before a bootloader overwrite occurs
				// Application is now corrupt, so do not hand over.

				DBG_TFTP(tracePGMlnTftp(mDebugTftp_FULL);)
   1e8b0:	6f e2       	ldi	r22, 0x2F	; 47
   1e8b2:	72 ee       	ldi	r23, 0xE2	; 226
   1e8b4:	8d ed       	ldi	r24, 0xDD	; 221
   1e8b6:	92 ee       	ldi	r25, 0xE2	; 226
   1e8b8:	f7 d1       	rcall	.+1006   	; 0x1eca8 <tracePGMln>

				returnCode = ERROR_FULL;
   1e8ba:	13 e0       	ldi	r17, 0x03	; 3
   1e8bc:	9f c0       	rjmp	.+318    	; 0x1e9fc <processPacket+0x3be>
			} else {

				DBG_TFTP(
   1e8be:	64 e1       	ldi	r22, 0x14	; 20
   1e8c0:	72 ee       	ldi	r23, 0xE2	; 226
   1e8c2:	8d ed       	ldi	r24, 0xDD	; 221
   1e8c4:	92 ee       	ldi	r25, 0xE2	; 226
   1e8c6:	f0 d1       	rcall	.+992    	; 0x1eca8 <tracePGMln>
   1e8c8:	46 e0       	ldi	r20, 0x06	; 6
   1e8ca:	c5 01       	movw	r24, r10
   1e8cc:	b4 01       	movw	r22, r8
   1e8ce:	1d d2       	rcall	.+1082   	; 0x1ed0a <tracehex>
				uint8_t* pageBase = buffer + (UDP_HEADER_SIZE + TFTP_OPCODE_SIZE + TFTP_BLOCKNO_SIZE); // Start of block data
				uint16_t offset = 0; // Block offset


				// Set the return code before packetLength gets rounded up
				if(packetLength < TFTP_DATA_SIZE) returnCode = FINAL_ACK;
   1e8d0:	c1 14       	cp	r12, r1
   1e8d2:	22 e0       	ldi	r18, 0x02	; 2
   1e8d4:	d2 06       	cpc	r13, r18
   1e8d6:	10 f4       	brcc	.+4      	; 0x1e8dc <processPacket+0x29e>
   1e8d8:	14 e0       	ldi	r17, 0x04	; 4
   1e8da:	01 c0       	rjmp	.+2      	; 0x1e8de <processPacket+0x2a0>
				else returnCode = ACK;
   1e8dc:	12 e0       	ldi	r17, 0x02	; 2

				// Round up packet length to a full flash sector size
				while(packetLength % SPM_PAGESIZE) packetLength++;
   1e8de:	cc 20       	and	r12, r12
   1e8e0:	21 f0       	breq	.+8      	; 0x1e8ea <processPacket+0x2ac>
   1e8e2:	8f ef       	ldi	r24, 0xFF	; 255
   1e8e4:	c8 1a       	sub	r12, r24
   1e8e6:	d8 0a       	sbc	r13, r24
   1e8e8:	fa cf       	rjmp	.-12     	; 0x1e8de <processPacket+0x2a0>

				DBG_TFTP(
   1e8ea:	69 ef       	ldi	r22, 0xF9	; 249
   1e8ec:	71 ee       	ldi	r23, 0xE1	; 225
   1e8ee:	8d ed       	ldi	r24, 0xDD	; 221
   1e8f0:	92 ee       	ldi	r25, 0xE2	; 226
   1e8f2:	da d1       	rcall	.+948    	; 0x1eca8 <tracePGMln>
   1e8f4:	c6 01       	movw	r24, r12
   1e8f6:	a0 e0       	ldi	r26, 0x00	; 0
   1e8f8:	b0 e0       	ldi	r27, 0x00	; 0
   1e8fa:	44 e0       	ldi	r20, 0x04	; 4
   1e8fc:	bc 01       	movw	r22, r24
   1e8fe:	cd 01       	movw	r24, r26
   1e900:	04 d2       	rcall	.+1032   	; 0x1ed0a <tracehex>
					tracePGMlnTftp(mDebugTftp_PLEN);
					tracenum(packetLength);
				)

				if(writeAddr == 0) {
   1e902:	81 14       	cp	r8, r1
   1e904:	91 04       	cpc	r9, r1
   1e906:	a1 04       	cpc	r10, r1
   1e908:	b1 04       	cpc	r11, r1
   1e90a:	19 f4       	brne	.+6      	; 0x1e912 <processPacket+0x2d4>
					// First sector - validate
					if(!validImage(pageBase)) {
   1e90c:	ce 01       	movw	r24, r28
   1e90e:	0d 96       	adiw	r24, 0x0d	; 13
   1e910:	93 d1       	rcall	.+806    	; 0x1ec38 <validImage>
   1e912:	de 01       	movw	r26, r28
   1e914:	1d 96       	adiw	r26, 0x0d	; 13
					}
				}

				// Flash packets
				uint16_t writeValue;
				for(offset = 0; offset < packetLength;) {
   1e916:	20 e0       	ldi	r18, 0x00	; 0
   1e918:	30 e0       	ldi	r19, 0x00	; 0
					writeValue = (pageBase[offset]) | (pageBase[offset + 1] << 8);
					boot_page_fill(writeAddr + offset, writeValue);
   1e91a:	33 24       	eor	r3, r3
   1e91c:	33 94       	inc	r3
					)

					offset += 2;

					if(offset % SPM_PAGESIZE == 0) {
						boot_page_erase(writeAddr + offset - SPM_PAGESIZE);
   1e91e:	24 01       	movw	r4, r8
   1e920:	35 01       	movw	r6, r10
   1e922:	91 e0       	ldi	r25, 0x01	; 1
   1e924:	59 1a       	sub	r5, r25
   1e926:	61 08       	sbc	r6, r1
   1e928:	71 08       	sbc	r7, r1
   1e92a:	03 e0       	ldi	r16, 0x03	; 3
						boot_spm_busy_wait();
						boot_page_write(writeAddr + offset - SPM_PAGESIZE);
   1e92c:	f5 e0       	ldi	r31, 0x05	; 5
   1e92e:	ff 2e       	mov	r15, r31
						boot_spm_busy_wait();
#if defined(RWWSRE)
						// Reenable read access to flash
						boot_rww_enable();
   1e930:	81 e1       	ldi	r24, 0x11	; 17
   1e932:	e8 2e       	mov	r14, r24
					}
				}

				// Flash packets
				uint16_t writeValue;
				for(offset = 0; offset < packetLength;) {
   1e934:	2c 15       	cp	r18, r12
   1e936:	3d 05       	cpc	r19, r13
   1e938:	08 f0       	brcs	.+2      	; 0x1e93c <processPacket+0x2fe>
   1e93a:	3b c0       	rjmp	.+118    	; 0x1e9b2 <processPacket+0x374>
					writeValue = (pageBase[offset]) | (pageBase[offset + 1] << 8);
					boot_page_fill(writeAddr + offset, writeValue);
   1e93c:	c5 01       	movw	r24, r10
   1e93e:	b4 01       	movw	r22, r8
   1e940:	62 0f       	add	r22, r18
   1e942:	73 1f       	adc	r23, r19
   1e944:	81 1d       	adc	r24, r1
   1e946:	91 1d       	adc	r25, r1
   1e948:	e1 e0       	ldi	r30, 0x01	; 1
   1e94a:	f0 e0       	ldi	r31, 0x00	; 0
   1e94c:	ec 0f       	add	r30, r28
   1e94e:	fd 1f       	adc	r31, r29
   1e950:	e2 0f       	add	r30, r18
   1e952:	f3 1f       	adc	r31, r19
				}

				// Flash packets
				uint16_t writeValue;
				for(offset = 0; offset < packetLength;) {
					writeValue = (pageBase[offset]) | (pageBase[offset + 1] << 8);
   1e954:	45 85       	ldd	r20, Z+13	; 0x0d
   1e956:	50 e0       	ldi	r21, 0x00	; 0
   1e958:	54 2f       	mov	r21, r20
   1e95a:	44 27       	eor	r20, r20
   1e95c:	ec 91       	ld	r30, X
   1e95e:	4e 2b       	or	r20, r30
					boot_page_fill(writeAddr + offset, writeValue);
   1e960:	0a 01       	movw	r0, r20
   1e962:	fb 01       	movw	r30, r22
   1e964:	80 93 5b 00 	sts	0x005B, r24
   1e968:	30 92 57 00 	sts	0x0057, r3
   1e96c:	e8 95       	spm
   1e96e:	11 24       	eor	r1, r1
							tracePGM(mDebugTftp_OFFSET);
							tracenum(writeAddr + offset);
						}
					)

					offset += 2;
   1e970:	2e 5f       	subi	r18, 0xFE	; 254
   1e972:	3f 4f       	sbci	r19, 0xFF	; 255

					if(offset % SPM_PAGESIZE == 0) {
   1e974:	21 11       	cpse	r18, r1
   1e976:	1b c0       	rjmp	.+54     	; 0x1e9ae <processPacket+0x370>
						boot_page_erase(writeAddr + offset - SPM_PAGESIZE);
   1e978:	b3 01       	movw	r22, r6
   1e97a:	a2 01       	movw	r20, r4
   1e97c:	42 0f       	add	r20, r18
   1e97e:	53 1f       	adc	r21, r19
   1e980:	61 1d       	adc	r22, r1
   1e982:	71 1d       	adc	r23, r1
   1e984:	fa 01       	movw	r30, r20
   1e986:	60 93 5b 00 	sts	0x005B, r22
   1e98a:	00 93 57 00 	sts	0x0057, r16
   1e98e:	e8 95       	spm
						boot_spm_busy_wait();
   1e990:	07 b6       	in	r0, 0x37	; 55
   1e992:	00 fc       	sbrc	r0, 0
   1e994:	fd cf       	rjmp	.-6      	; 0x1e990 <processPacket+0x352>
						boot_page_write(writeAddr + offset - SPM_PAGESIZE);
   1e996:	fa 01       	movw	r30, r20
   1e998:	60 93 5b 00 	sts	0x005B, r22
   1e99c:	f0 92 57 00 	sts	0x0057, r15
   1e9a0:	e8 95       	spm
						boot_spm_busy_wait();
   1e9a2:	07 b6       	in	r0, 0x37	; 55
   1e9a4:	00 fc       	sbrc	r0, 0
   1e9a6:	fd cf       	rjmp	.-6      	; 0x1e9a2 <processPacket+0x364>
#if defined(RWWSRE)
						// Reenable read access to flash
						boot_rww_enable();
   1e9a8:	e0 92 57 00 	sts	0x0057, r14
   1e9ac:	e8 95       	spm
   1e9ae:	12 96       	adiw	r26, 0x02	; 2
   1e9b0:	c1 cf       	rjmp	.-126    	; 0x1e934 <processPacket+0x2f6>
#endif
					}
				}

				if(returnCode == FINAL_ACK) {
   1e9b2:	14 30       	cpi	r17, 0x04	; 4
   1e9b4:	19 f5       	brne	.+70     	; 0x1e9fc <processPacket+0x3be>
					// Flash is complete
					// Hand over to application

					DBG_TFTP(tracePGMlnTftp(mDebugTftp_DONE);)
   1e9b6:	67 ee       	ldi	r22, 0xE7	; 231
   1e9b8:	71 ee       	ldi	r23, 0xE1	; 225
   1e9ba:	8d ed       	ldi	r24, 0xDD	; 221
   1e9bc:	92 ee       	ldi	r25, 0xE2	; 226
   1e9be:	74 d1       	rcall	.+744    	; 0x1eca8 <tracePGMln>

					// Flag the image as valid since we received the last packet
					eeprom_write_byte(EEPROM_IMG_STAT, EEPROM_IMG_OK_VALUE);
   1e9c0:	6e ee       	ldi	r22, 0xEE	; 238
   1e9c2:	82 e0       	ldi	r24, 0x02	; 2
   1e9c4:	90 e0       	ldi	r25, 0x00	; 0
   1e9c6:	5d d3       	rcall	.+1722   	; 0x1f082 <__eewr_byte_m1284p>
   1e9c8:	19 c0       	rjmp	.+50     	; 0x1e9fc <processPacket+0x3be>
			break;

		// Acknowledgment
		case TFTP_OPCODE_ACK:

			DBG_TFTP(tracePGMlnTftp(mDebugTftp_OPACK);)
   1e9ca:	6b ed       	ldi	r22, 0xDB	; 219
   1e9cc:	71 ee       	ldi	r23, 0xE1	; 225
			break;

		// Error signal
		case TFTP_OPCODE_ERROR:

			DBG_TFTP(tracePGMlnTftp(mDebugTftp_OPERR);)
   1e9ce:	8d ed       	ldi	r24, 0xDD	; 221
   1e9d0:	92 ee       	ldi	r25, 0xE2	; 226
   1e9d2:	6a d1       	rcall	.+724    	; 0x1eca8 <tracePGMln>
		tftpOpcode = TFTP_OPCODE_UKN;

	if(tftpDataLen > (0x200 + TFTP_OPCODE_SIZE + TFTP_BLOCKNO_SIZE))
		tftpOpcode = TFTP_OPCODE_UKN;

	uint8_t returnCode = ERROR_UNKNOWN;
   1e9d4:	10 e0       	ldi	r17, 0x00	; 0
		case TFTP_OPCODE_ERROR:

			DBG_TFTP(tracePGMlnTftp(mDebugTftp_OPERR);)

			/* FIXME: Resetting might be needed here too */
			break;
   1e9d6:	12 c0       	rjmp	.+36     	; 0x1e9fc <processPacket+0x3be>
	if((tftpOpcode == TFTP_OPCODE_DATA)
		&& ((tftpBlock > MAX_ADDR / 0x200) || (tftpBlock < highPacket) || (tftpBlock > highPacket + 1)))
		tftpOpcode = TFTP_OPCODE_UKN;

	if(tftpDataLen > (0x200 + TFTP_OPCODE_SIZE + TFTP_BLOCKNO_SIZE))
		tftpOpcode = TFTP_OPCODE_UKN;
   1e9d8:	00 e0       	ldi	r16, 0x00	; 0
   1e9da:	10 e0       	ldi	r17, 0x00	; 0

			/* FIXME: Resetting might be needed here too */
			break;

		default:
			DBG_TFTP(
   1e9dc:	65 ec       	ldi	r22, 0xC5	; 197
   1e9de:	71 ee       	ldi	r23, 0xE1	; 225
   1e9e0:	8d ed       	ldi	r24, 0xDD	; 221
   1e9e2:	92 ee       	ldi	r25, 0xE2	; 226
   1e9e4:	61 d1       	rcall	.+706    	; 0x1eca8 <tracePGMln>
   1e9e6:	b8 01       	movw	r22, r16
   1e9e8:	80 e0       	ldi	r24, 0x00	; 0
   1e9ea:	90 e0       	ldi	r25, 0x00	; 0
   1e9ec:	44 e0       	ldi	r20, 0x04	; 4
   1e9ee:	8d d1       	rcall	.+794    	; 0x1ed0a <tracehex>
			)

#if defined(RANDOM_TFTP_DATA_PORT)
			sockInit((buffer[4] << 8) | ~buffer[5]); // Generate a 'random' TID (RFC1350)
#else
			sockInit(tftpTransferPort);
   1e9f0:	80 91 27 01 	lds	r24, 0x0127
   1e9f4:	90 91 28 01 	lds	r25, 0x0128
   1e9f8:	f4 dd       	rcall	.-1048   	; 0x1e5e2 <sockInit>
			 * It can be done by reinitializig the tftpd or
			 * by resetting the device. I should find out which is best...
			 * Right now it is being done by resetting the timer if we have a
			 * data packet. */
			// Invalid - return error
			returnCode = ERROR_INVALID;
   1e9fa:	11 e0       	ldi	r17, 0x01	; 1
			break;

	}

	return(returnCode);
}
   1e9fc:	81 2f       	mov	r24, r17
   1e9fe:	c4 5f       	subi	r28, 0xF4	; 244
   1ea00:	dd 4f       	sbci	r29, 0xFD	; 253
   1ea02:	de bf       	out	0x3e, r29	; 62
   1ea04:	cd bf       	out	0x3d, r28	; 61
   1ea06:	df 91       	pop	r29
   1ea08:	cf 91       	pop	r28
   1ea0a:	1f 91       	pop	r17
   1ea0c:	0f 91       	pop	r16
   1ea0e:	ff 90       	pop	r15
   1ea10:	ef 90       	pop	r14
   1ea12:	df 90       	pop	r13
   1ea14:	cf 90       	pop	r12
   1ea16:	bf 90       	pop	r11
   1ea18:	af 90       	pop	r10
   1ea1a:	9f 90       	pop	r9
   1ea1c:	8f 90       	pop	r8
   1ea1e:	7f 90       	pop	r7
   1ea20:	6f 90       	pop	r6
   1ea22:	5f 90       	pop	r5
   1ea24:	4f 90       	pop	r4
   1ea26:	3f 90       	pop	r3
   1ea28:	08 95       	ret

0001ea2a <tftpInit>:

/**
 * Initializes the network controller
 */
void tftpInit(void)
{
   1ea2a:	cf 93       	push	r28
	// Open socket
	sockInit(TFTP_PORT);
   1ea2c:	85 e4       	ldi	r24, 0x45	; 69
   1ea2e:	90 e0       	ldi	r25, 0x00	; 0
   1ea30:	d8 dd       	rcall	.-1104   	; 0x1e5e2 <sockInit>

#if defined(RANDOM_TFTP_DATA_PORT)
#else
	if(eeprom_read_byte(EEPROM_SIG_3) == EEPROM_SIG_3_VALUE)
   1ea32:	87 e1       	ldi	r24, 0x17	; 23
   1ea34:	90 e0       	ldi	r25, 0x00	; 0
   1ea36:	1d d3       	rcall	.+1594   	; 0x1f072 <__eerd_byte_m1284p>
   1ea38:	8b 3b       	cpi	r24, 0xBB	; 187
   1ea3a:	91 f4       	brne	.+36     	; 0x1ea60 <tftpInit+0x36>
		tftpTransferPort = ((eeprom_read_byte(EEPROM_PORT + 1) << 8) + eeprom_read_byte(EEPROM_PORT));
   1ea3c:	89 e1       	ldi	r24, 0x19	; 25
   1ea3e:	90 e0       	ldi	r25, 0x00	; 0
   1ea40:	18 d3       	rcall	.+1584   	; 0x1f072 <__eerd_byte_m1284p>
   1ea42:	c8 2f       	mov	r28, r24
   1ea44:	88 e1       	ldi	r24, 0x18	; 24
   1ea46:	90 e0       	ldi	r25, 0x00	; 0
   1ea48:	14 d3       	rcall	.+1576   	; 0x1f072 <__eerd_byte_m1284p>
   1ea4a:	2c 2f       	mov	r18, r28
   1ea4c:	30 e0       	ldi	r19, 0x00	; 0
   1ea4e:	32 2f       	mov	r19, r18
   1ea50:	22 27       	eor	r18, r18
   1ea52:	28 0f       	add	r18, r24
   1ea54:	31 1d       	adc	r19, r1
   1ea56:	30 93 28 01 	sts	0x0128, r19
   1ea5a:	20 93 27 01 	sts	0x0127, r18
   1ea5e:	06 c0       	rjmp	.+12     	; 0x1ea6c <tftpInit+0x42>
	else
		tftpTransferPort = TFTP_DATA_PORT;
   1ea60:	89 e7       	ldi	r24, 0x79	; 121
   1ea62:	97 eb       	ldi	r25, 0xB7	; 183
   1ea64:	90 93 28 01 	sts	0x0128, r25
   1ea68:	80 93 27 01 	sts	0x0127, r24
#endif

	DBG_TFTP(
   1ea6c:	69 e8       	ldi	r22, 0x89	; 137
   1ea6e:	71 ee       	ldi	r23, 0xE1	; 225
   1ea70:	8d ed       	ldi	r24, 0xDD	; 221
   1ea72:	92 ee       	ldi	r25, 0xE2	; 226
   1ea74:	19 d1       	rcall	.+562    	; 0x1eca8 <tracePGMln>
   1ea76:	6d e7       	ldi	r22, 0x7D	; 125
   1ea78:	71 ee       	ldi	r23, 0xE1	; 225
   1ea7a:	8d ed       	ldi	r24, 0xDD	; 221
   1ea7c:	92 ee       	ldi	r25, 0xE2	; 226
   1ea7e:	14 d1       	rcall	.+552    	; 0x1eca8 <tracePGMln>
   1ea80:	60 91 27 01 	lds	r22, 0x0127
   1ea84:	70 91 28 01 	lds	r23, 0x0128
   1ea88:	80 e0       	ldi	r24, 0x00	; 0
   1ea8a:	90 e0       	ldi	r25, 0x00	; 0
   1ea8c:	44 e0       	ldi	r20, 0x04	; 4
#else
		tracePGMlnTftp(mDebugTftp_PORT);
		tracenum(tftpTransferPort);
#endif
	)
}
   1ea8e:	cf 91       	pop	r28
		tftpTransferPort = ((eeprom_read_byte(EEPROM_PORT + 1) << 8) + eeprom_read_byte(EEPROM_PORT));
	else
		tftpTransferPort = TFTP_DATA_PORT;
#endif

	DBG_TFTP(
   1ea90:	3c c1       	rjmp	.+632    	; 0x1ed0a <tracehex>

0001ea92 <tftpPoll>:

/**
 * Looks for a connection
 */
uint8_t tftpPoll(void)
{
   1ea92:	af 92       	push	r10
   1ea94:	bf 92       	push	r11
   1ea96:	cf 92       	push	r12
   1ea98:	df 92       	push	r13
   1ea9a:	ef 92       	push	r14
   1ea9c:	ff 92       	push	r15
   1ea9e:	0f 93       	push	r16
   1eaa0:	1f 93       	push	r17
   1eaa2:	cf 93       	push	r28
   1eaa4:	df 93       	push	r29
   1eaa6:	cd b7       	in	r28, 0x3d	; 61
   1eaa8:	de b7       	in	r29, 0x3e	; 62
   1eaaa:	c4 56       	subi	r28, 0x64	; 100
   1eaac:	d1 09       	sbc	r29, r1
   1eaae:	de bf       	out	0x3e, r29	; 62
   1eab0:	cd bf       	out	0x3d, r28	; 61
	uint8_t response = ACK;
	// Get the size of the recieved data
	uint16_t packetSize = spiReadWord(REG_S3_RX_RSR0);
   1eab2:	86 e2       	ldi	r24, 0x26	; 38
   1eab4:	97 e0       	ldi	r25, 0x07	; 7
   1eab6:	e8 dc       	rcall	.-1584   	; 0x1e488 <spiReadWord>
// 			_delay_ms(400);
// 			packetSize = spiReadWord(REG_S3_RX_RSR0);
// 		}
// 	} while (packetSize != incSize);

	if(packetSize) {
   1eab8:	89 2b       	or	r24, r25
   1eaba:	11 f4       	brne	.+4      	; 0x1eac0 <tftpPoll+0x2e>
		// Complete
		return(0);
	}

	// Tftp continues
	return(1);
   1eabc:	81 e0       	ldi	r24, 0x01	; 1
   1eabe:	ad c0       	rjmp	.+346    	; 0x1ec1a <tftpPoll+0x188>
// 			packetSize = spiReadWord(REG_S3_RX_RSR0);
// 		}
// 	} while (packetSize != incSize);

	if(packetSize) {
		tftpFlashing = TRUE;
   1eac0:	81 e0       	ldi	r24, 0x01	; 1
   1eac2:	80 93 2a 01 	sts	0x012A, r24

		while((spiReadReg(REG_S3_IR) & IR_RECV)) {
   1eac6:	82 e0       	ldi	r24, 0x02	; 2
   1eac8:	97 e0       	ldi	r25, 0x07	; 7
   1eaca:	c4 dc       	rcall	.-1656   	; 0x1e454 <spiReadReg>
   1eacc:	82 ff       	sbrs	r24, 2
   1eace:	0e c0       	rjmp	.+28     	; 0x1eaec <tftpPoll+0x5a>
			spiWriteReg(REG_S3_IR, IR_RECV);
   1ead0:	64 e0       	ldi	r22, 0x04	; 4
   1ead2:	82 e0       	ldi	r24, 0x02	; 2
   1ead4:	97 e0       	ldi	r25, 0x07	; 7
   1ead6:	94 dc       	rcall	.-1752   	; 0x1e400 <spiWriteReg>
   1ead8:	2f ef       	ldi	r18, 0xFF	; 255
   1eada:	37 e8       	ldi	r19, 0x87	; 135
   1eadc:	83 e1       	ldi	r24, 0x13	; 19
   1eade:	21 50       	subi	r18, 0x01	; 1
   1eae0:	30 40       	sbci	r19, 0x00	; 0
   1eae2:	80 40       	sbci	r24, 0x00	; 0
   1eae4:	e1 f7       	brne	.-8      	; 0x1eade <tftpPoll+0x4c>
   1eae6:	00 c0       	rjmp	.+0      	; 0x1eae8 <tftpPoll+0x56>
   1eae8:	00 00       	nop
   1eaea:	ed cf       	rjmp	.-38     	; 0x1eac6 <tftpPoll+0x34>
			_delay_ms(TFTP_PACKET_DELAY);
		}

		// Process Packet and get TFTP response code
#if (DEBUG_TFTP > 0)
		packetSize = spiReadWord(REG_S3_RX_RSR0);
   1eaec:	86 e2       	ldi	r24, 0x26	; 38
   1eaee:	97 e0       	ldi	r25, 0x07	; 7
   1eaf0:	cb dc       	rcall	.-1642   	; 0x1e488 <spiReadWord>
		response = processPacket(packetSize);
   1eaf2:	a5 dd       	rcall	.-1206   	; 0x1e63e <processPacket>
   1eaf4:	f8 2e       	mov	r15, r24
	uint8_t txBuffer[100];
	uint8_t* txPtr = txBuffer;
	uint8_t packetLength;
	uint16_t writePointer;

	writePointer = spiReadWord(REG_S3_TX_WR0) + S3_TX_START;
   1eaf6:	84 e2       	ldi	r24, 0x24	; 36
   1eaf8:	97 e0       	ldi	r25, 0x07	; 7
   1eafa:	c6 dc       	rcall	.-1652   	; 0x1e488 <spiReadWord>
   1eafc:	8c 01       	movw	r16, r24
   1eafe:	18 5a       	subi	r17, 0xA8	; 168

	switch(response) {
   1eb00:	92 e0       	ldi	r25, 0x02	; 2
   1eb02:	f9 16       	cp	r15, r25
   1eb04:	c9 f1       	breq	.+114    	; 0x1eb78 <tftpPoll+0xe6>
   1eb06:	9f 15       	cp	r25, r15
   1eb08:	20 f0       	brcs	.+8      	; 0x1eb12 <tftpPoll+0x80>
   1eb0a:	e1 e0       	ldi	r30, 0x01	; 1
   1eb0c:	fe 16       	cp	r15, r30
   1eb0e:	d1 f0       	breq	.+52     	; 0x1eb44 <tftpPoll+0xb2>
   1eb10:	07 c0       	rjmp	.+14     	; 0x1eb20 <tftpPoll+0x8e>
   1eb12:	f3 e0       	ldi	r31, 0x03	; 3
   1eb14:	ff 16       	cp	r15, r31
   1eb16:	19 f1       	breq	.+70     	; 0x1eb5e <tftpPoll+0xcc>
   1eb18:	24 e0       	ldi	r18, 0x04	; 4
   1eb1a:	f2 16       	cp	r15, r18
   1eb1c:	09 f4       	brne	.+2      	; 0x1eb20 <tftpPoll+0x8e>
   1eb1e:	7a c0       	rjmp	.+244    	; 0x1ec14 <tftpPoll+0x182>

		case ERROR_UNKNOWN:
			// Send unknown error packet
			packetLength = TFTP_UNKNOWN_ERROR_LEN;
#if (FLASHEND > 0x10000)
			memcpy_PF(txBuffer, PROGMEM_OFFSET + (uint32_t)(uint16_t)tftp_unknown_error_packet, packetLength);
   1eb20:	46 e4       	ldi	r20, 0x46	; 70
   1eb22:	51 ee       	ldi	r21, 0xE1	; 225
   1eb24:	60 e0       	ldi	r22, 0x00	; 0
   1eb26:	70 e0       	ldi	r23, 0x00	; 0
   1eb28:	6f 5f       	subi	r22, 0xFF	; 255
   1eb2a:	7f 4f       	sbci	r23, 0xFF	; 255
   1eb2c:	2a e0       	ldi	r18, 0x0A	; 10
   1eb2e:	30 e0       	ldi	r19, 0x00	; 0
   1eb30:	ce 01       	movw	r24, r28
   1eb32:	01 96       	adiw	r24, 0x01	; 1
   1eb34:	94 d2       	rcall	.+1320   	; 0x1f05e <memcpy_PF>
	switch(response) {
		default:

		case ERROR_UNKNOWN:
			// Send unknown error packet
			packetLength = TFTP_UNKNOWN_ERROR_LEN;
   1eb36:	8a e0       	ldi	r24, 0x0A	; 10
	txPtr = txBuffer;

	while(packetLength--) {
		spiWriteReg(writePointer++, *txPtr++);

		if(writePointer == S3_TX_END) writePointer = S3_TX_START;
   1eb38:	fe 01       	movw	r30, r28
   1eb3a:	31 96       	adiw	r30, 0x01	; 1
   1eb3c:	6f 01       	movw	r12, r30
   1eb3e:	e8 2e       	mov	r14, r24
   1eb40:	ee 0e       	add	r14, r30
   1eb42:	4a c0       	rjmp	.+148    	; 0x1ebd8 <tftpPoll+0x146>

		case ERROR_INVALID:
			// Send invalid opcode packet
			packetLength = TFTP_OPCODE_ERROR_LEN;
#if (FLASHEND > 0x10000)
			memcpy_PF(txBuffer, PROGMEM_OFFSET + (uint32_t)(uint16_t)tftp_opcode_error_packet, packetLength);
   1eb44:	4b e5       	ldi	r20, 0x5B	; 91
   1eb46:	51 ee       	ldi	r21, 0xE1	; 225
   1eb48:	60 e0       	ldi	r22, 0x00	; 0
   1eb4a:	70 e0       	ldi	r23, 0x00	; 0
   1eb4c:	6f 5f       	subi	r22, 0xFF	; 255
   1eb4e:	7f 4f       	sbci	r23, 0xFF	; 255
   1eb50:	2c e0       	ldi	r18, 0x0C	; 12
   1eb52:	30 e0       	ldi	r19, 0x00	; 0
   1eb54:	ce 01       	movw	r24, r28
   1eb56:	01 96       	adiw	r24, 0x01	; 1
   1eb58:	82 d2       	rcall	.+1284   	; 0x1f05e <memcpy_PF>
#endif
			break;

		case ERROR_INVALID:
			// Send invalid opcode packet
			packetLength = TFTP_OPCODE_ERROR_LEN;
   1eb5a:	8c e0       	ldi	r24, 0x0C	; 12
   1eb5c:	ed cf       	rjmp	.-38     	; 0x1eb38 <tftpPoll+0xa6>

		case ERROR_FULL:
			// Send unknown error packet
			packetLength = TFTP_FULL_ERROR_LEN;
#if (FLASHEND > 0x10000)
			memcpy_PF(txBuffer, PROGMEM_OFFSET + (uint32_t)(uint16_t)tftp_full_error_packet, packetLength);
   1eb5e:	41 e5       	ldi	r20, 0x51	; 81
   1eb60:	51 ee       	ldi	r21, 0xE1	; 225
   1eb62:	60 e0       	ldi	r22, 0x00	; 0
   1eb64:	70 e0       	ldi	r23, 0x00	; 0
   1eb66:	6f 5f       	subi	r22, 0xFF	; 255
   1eb68:	7f 4f       	sbci	r23, 0xFF	; 255
   1eb6a:	29 e0       	ldi	r18, 0x09	; 9
   1eb6c:	30 e0       	ldi	r19, 0x00	; 0
   1eb6e:	ce 01       	movw	r24, r28
   1eb70:	01 96       	adiw	r24, 0x01	; 1
   1eb72:	75 d2       	rcall	.+1258   	; 0x1f05e <memcpy_PF>
#endif
			break;

		case ERROR_FULL:
			// Send unknown error packet
			packetLength = TFTP_FULL_ERROR_LEN;
   1eb74:	89 e0       	ldi	r24, 0x09	; 9
   1eb76:	e0 cf       	rjmp	.-64     	; 0x1eb38 <tftpPoll+0xa6>
			memcpy_P(txBuffer, tftp_full_error_packet, packetLength);
#endif
			break;

		case ACK:
			if(lastPacket > highPacket) highPacket = lastPacket;
   1eb78:	80 91 1e 01 	lds	r24, 0x011E
   1eb7c:	90 91 1f 01 	lds	r25, 0x011F
   1eb80:	20 91 1c 01 	lds	r18, 0x011C
   1eb84:	30 91 1d 01 	lds	r19, 0x011D
   1eb88:	28 17       	cp	r18, r24
   1eb8a:	39 07       	cpc	r19, r25
   1eb8c:	20 f4       	brcc	.+8      	; 0x1eb96 <tftpPoll+0x104>
   1eb8e:	90 93 1d 01 	sts	0x011D, r25
   1eb92:	80 93 1c 01 	sts	0x011C, r24

			DBG_TFTP(tracePGMlnTftp(mDebugTftp_SACK);)
   1eb96:	6c eb       	ldi	r22, 0xBC	; 188
   1eb98:	71 ee       	ldi	r23, 0xE1	; 225
   1eb9a:	8d ed       	ldi	r24, 0xDD	; 221
   1eb9c:	92 ee       	ldi	r25, 0xE2	; 226
   1eb9e:	84 d0       	rcall	.+264    	; 0x1eca8 <tracePGMln>
				if(response == FINAL_ACK)
					tracePGMlnTftp(mDebugTftp_SFACK);
			)

			packetLength = 4;
			*txPtr++ = TFTP_OPCODE_ACK >> 8;
   1eba0:	19 82       	std	Y+1, r1	; 0x01
			*txPtr++ = TFTP_OPCODE_ACK & 0xff;
   1eba2:	84 e0       	ldi	r24, 0x04	; 4
   1eba4:	8a 83       	std	Y+2, r24	; 0x02
			// lastPacket is block code
			*txPtr++ = lastPacket >> 8;
   1eba6:	80 91 1e 01 	lds	r24, 0x011E
   1ebaa:	90 91 1f 01 	lds	r25, 0x011F
   1ebae:	9b 83       	std	Y+3, r25	; 0x03
			*txPtr = lastPacket & 0xff;
   1ebb0:	8c 83       	std	Y+4, r24	; 0x04
			DBG_TFTP(
				if(response == FINAL_ACK)
					tracePGMlnTftp(mDebugTftp_SFACK);
			)

			packetLength = 4;
   1ebb2:	84 e0       	ldi	r24, 0x04	; 4
   1ebb4:	c1 cf       	rjmp	.-126    	; 0x1eb38 <tftpPoll+0xa6>
	}

	txPtr = txBuffer;

	while(packetLength--) {
		spiWriteReg(writePointer++, *txPtr++);
   1ebb6:	f6 01       	movw	r30, r12
   1ebb8:	61 91       	ld	r22, Z+
   1ebba:	6f 01       	movw	r12, r30
   1ebbc:	58 01       	movw	r10, r16
   1ebbe:	ff ef       	ldi	r31, 0xFF	; 255
   1ebc0:	af 1a       	sub	r10, r31
   1ebc2:	bf 0a       	sbc	r11, r31
   1ebc4:	c8 01       	movw	r24, r16
   1ebc6:	1c dc       	rcall	.-1992   	; 0x1e400 <spiWriteReg>

		if(writePointer == S3_TX_END) writePointer = S3_TX_START;
   1ebc8:	a1 14       	cp	r10, r1
   1ebca:	20 e6       	ldi	r18, 0x60	; 96
   1ebcc:	b2 06       	cpc	r11, r18
   1ebce:	19 f4       	brne	.+6      	; 0x1ebd6 <tftpPoll+0x144>
   1ebd0:	a1 2c       	mov	r10, r1
   1ebd2:	f8 e5       	ldi	r31, 0x58	; 88
   1ebd4:	bf 2e       	mov	r11, r31
   1ebd6:	85 01       	movw	r16, r10
			break;
	}

	txPtr = txBuffer;

	while(packetLength--) {
   1ebd8:	ec 10       	cpse	r14, r12
   1ebda:	ed cf       	rjmp	.-38     	; 0x1ebb6 <tftpPoll+0x124>
		spiWriteReg(writePointer++, *txPtr++);

		if(writePointer == S3_TX_END) writePointer = S3_TX_START;
	}

	spiWriteWord(REG_S3_TX_WR0, writePointer - S3_TX_START);
   1ebdc:	b8 01       	movw	r22, r16
   1ebde:	78 55       	subi	r23, 0x58	; 88
   1ebe0:	84 e2       	ldi	r24, 0x24	; 36
   1ebe2:	97 e0       	ldi	r25, 0x07	; 7
   1ebe4:	26 dc       	rcall	.-1972   	; 0x1e432 <spiWriteWord>
	spiWriteReg(REG_S3_CR, CR_SEND);
   1ebe6:	60 e2       	ldi	r22, 0x20	; 32
   1ebe8:	81 e0       	ldi	r24, 0x01	; 1
   1ebea:	97 e0       	ldi	r25, 0x07	; 7
   1ebec:	09 dc       	rcall	.-2030   	; 0x1e400 <spiWriteReg>

	while(spiReadReg(REG_S3_CR));
   1ebee:	81 e0       	ldi	r24, 0x01	; 1
   1ebf0:	97 e0       	ldi	r25, 0x07	; 7
   1ebf2:	30 dc       	rcall	.-1952   	; 0x1e454 <spiReadReg>
   1ebf4:	81 11       	cpse	r24, r1
   1ebf6:	fb cf       	rjmp	.-10     	; 0x1ebee <tftpPoll+0x15c>

	DBG_TFTP(tracePGMlnTftp(mDebugTftp_RESP);)
   1ebf8:	6f e9       	ldi	r22, 0x9F	; 159
   1ebfa:	71 ee       	ldi	r23, 0xE1	; 225
   1ebfc:	8d ed       	ldi	r24, 0xDD	; 221
   1ebfe:	92 ee       	ldi	r25, 0xE2	; 226
   1ec00:	53 d0       	rcall	.+166    	; 0x1eca8 <tracePGMln>
#endif
		// Send the response
		sendResponse(response);
	}

	if(response == FINAL_ACK) {
   1ec02:	34 e0       	ldi	r19, 0x04	; 4
   1ec04:	f3 12       	cpse	r15, r19
   1ec06:	5a cf       	rjmp	.-332    	; 0x1eabc <tftpPoll+0x2a>
		spiWriteReg(REG_S3_CR, CR_CLOSE);
   1ec08:	60 e1       	ldi	r22, 0x10	; 16
   1ec0a:	81 e0       	ldi	r24, 0x01	; 1
   1ec0c:	97 e0       	ldi	r25, 0x07	; 7
   1ec0e:	f8 db       	rcall	.-2064   	; 0x1e400 <spiWriteReg>
		// Complete
		return(0);
   1ec10:	80 e0       	ldi	r24, 0x00	; 0
   1ec12:	03 c0       	rjmp	.+6      	; 0x1ec1a <tftpPoll+0x188>
			DBG_TFTP(tracePGMlnTftp(mDebugTftp_SACK);)
			/* no break */

		case FINAL_ACK:

			DBG_TFTP(
   1ec14:	6d ea       	ldi	r22, 0xAD	; 173
   1ec16:	71 ee       	ldi	r23, 0xE1	; 225
   1ec18:	c0 cf       	rjmp	.-128    	; 0x1eb9a <tftpPoll+0x108>
		return(0);
	}

	// Tftp continues
	return(1);
}
   1ec1a:	cc 59       	subi	r28, 0x9C	; 156
   1ec1c:	df 4f       	sbci	r29, 0xFF	; 255
   1ec1e:	de bf       	out	0x3e, r29	; 62
   1ec20:	cd bf       	out	0x3d, r28	; 61
   1ec22:	df 91       	pop	r29
   1ec24:	cf 91       	pop	r28
   1ec26:	1f 91       	pop	r17
   1ec28:	0f 91       	pop	r16
   1ec2a:	ff 90       	pop	r15
   1ec2c:	ef 90       	pop	r14
   1ec2e:	df 90       	pop	r13
   1ec30:	cf 90       	pop	r12
   1ec32:	bf 90       	pop	r11
   1ec34:	af 90       	pop	r10
   1ec36:	08 95       	ret

0001ec38 <validImage>:
#include "serial.h"
#include "debug.h"
#include "debug_vald.h"

uint8_t validImage(uint8_t* base)
{
   1ec38:	20 e0       	ldi	r18, 0x00	; 0
   1ec3a:	30 e0       	ldi	r19, 0x00	; 0
   1ec3c:	fc 01       	movw	r30, r24
   1ec3e:	e2 0f       	add	r30, r18
   1ec40:	f3 1f       	adc	r31, r19
	uint8_t i;
	for(i = 0; i < 0x34; i += 4) {

		// For each vector, check it is of the form:
		// 0x0C 0x94 0xWX 0xYZ  ; JMP 0xWXYZ
		if(base[i] != 0x0c) {
   1ec42:	40 81       	ld	r20, Z
   1ec44:	4c 30       	cpi	r20, 0x0C	; 12
   1ec46:	51 f4       	brne	.+20     	; 0x1ec5c <validImage+0x24>
				tracePGM(mDebugVald_0x0C);
			)
			return(0);
		}
		
		if(base[i + 1] != 0x94) {
   1ec48:	41 81       	ldd	r20, Z+1	; 0x01
   1ec4a:	44 39       	cpi	r20, 0x94	; 148
   1ec4c:	39 f4       	brne	.+14     	; 0x1ec5c <validImage+0x24>
   1ec4e:	2c 5f       	subi	r18, 0xFC	; 252
   1ec50:	3f 4f       	sbci	r19, 0xFF	; 255

uint8_t validImage(uint8_t* base)
{
	/* Check that a jump table is present in the first flash sector */
	uint8_t i;
	for(i = 0; i < 0x34; i += 4) {
   1ec52:	24 33       	cpi	r18, 0x34	; 52
   1ec54:	31 05       	cpc	r19, r1
   1ec56:	91 f7       	brne	.-28     	; 0x1ec3c <validImage+0x4>
		}
	}

	DBG_VALD(tracePGMlnVald(mDebugVald_VALID);)

	return(1);
   1ec58:	81 e0       	ldi	r24, 0x01	; 1
}
   1ec5a:	08 95       	ret
				tracenum(i);
				tracePGM(mDebugVald_WITH);
				tracenum(base[i]);
				tracePGM(mDebugVald_0x0C);
			)
			return(0);
   1ec5c:	80 e0       	ldi	r24, 0x00	; 0
   1ec5e:	08 95       	ret

0001ec60 <tracePGM>:
 */
const unsigned char mDebug_NEWLINE[]	PROGMEM =	"\r\n";
const unsigned char mDebug_HEXPREF[]	PROGMEM =	"0x";

void tracePGM(const void* p_msg)
{
   1ec60:	cf 92       	push	r12
   1ec62:	df 92       	push	r13
   1ec64:	ef 92       	push	r14
   1ec66:	ff 92       	push	r15
   1ec68:	cf 93       	push	r28
   1ec6a:	df 93       	push	r29
	uint8_t	c = 1, i = 0;
   1ec6c:	d0 e0       	ldi	r29, 0x00	; 0
#if (FLASHEND > 0x10000)
		/* 0x30000 was added to fix the issues of progmem with >64Kb flash.
		 * 0x30000 is specific to atmega2560 and won't work on smaller or larger flashes.
		 * I should find a way to macro the calculation of this value
		 */
		c = pgm_read_byte_far(PROGMEM_OFFSET + (uint32_t)(uint16_t)p_msg + i);
   1ec6e:	6c 01       	movw	r12, r24
   1ec70:	e1 2c       	mov	r14, r1
   1ec72:	f1 2c       	mov	r15, r1
   1ec74:	8f ef       	ldi	r24, 0xFF	; 255
   1ec76:	e8 1a       	sub	r14, r24
   1ec78:	f8 0a       	sbc	r15, r24
   1ec7a:	d7 01       	movw	r26, r14
   1ec7c:	c6 01       	movw	r24, r12
   1ec7e:	8d 0f       	add	r24, r29
   1ec80:	91 1d       	adc	r25, r1
   1ec82:	a1 1d       	adc	r26, r1
   1ec84:	b1 1d       	adc	r27, r1
   1ec86:	ab bf       	out	0x3b, r26	; 59
   1ec88:	fc 01       	movw	r30, r24
   1ec8a:	c7 91       	elpm	r28, Z+
#else
		c = pgm_read_byte_near((uint16_t)p_msg + i);
#endif
		if (c != 0) putch(c);
   1ec8c:	cc 23       	and	r28, r28
   1ec8e:	11 f0       	breq	.+4      	; 0x1ec94 <tracePGM+0x34>
   1ec90:	8c 2f       	mov	r24, r28
   1ec92:	70 d0       	rcall	.+224    	; 0x1ed74 <putch>
		i++;
   1ec94:	df 5f       	subi	r29, 0xFF	; 255

void tracePGM(const void* p_msg)
{
	uint8_t	c = 1, i = 0;

	while(c != 0){
   1ec96:	c1 11       	cpse	r28, r1
   1ec98:	f0 cf       	rjmp	.-32     	; 0x1ec7a <tracePGM+0x1a>
		c = pgm_read_byte_near((uint16_t)p_msg + i);
#endif
		if (c != 0) putch(c);
		i++;
	}
}
   1ec9a:	df 91       	pop	r29
   1ec9c:	cf 91       	pop	r28
   1ec9e:	ff 90       	pop	r15
   1eca0:	ef 90       	pop	r14
   1eca2:	df 90       	pop	r13
   1eca4:	cf 90       	pop	r12
   1eca6:	08 95       	ret

0001eca8 <tracePGMln>:


void tracePGMln(const void* p_prefix, const void* p_msg)
{
   1eca8:	0f 93       	push	r16
   1ecaa:	1f 93       	push	r17
   1ecac:	cf 93       	push	r28
   1ecae:	df 93       	push	r29
   1ecb0:	ec 01       	movw	r28, r24
   1ecb2:	8b 01       	movw	r16, r22
	tracePGM(mDebug_NEWLINE);
   1ecb4:	87 ee       	ldi	r24, 0xE7	; 231
   1ecb6:	92 ee       	ldi	r25, 0xE2	; 226
   1ecb8:	d3 df       	rcall	.-90     	; 0x1ec60 <tracePGM>
	tracePGM(p_prefix);
   1ecba:	ce 01       	movw	r24, r28
   1ecbc:	d1 df       	rcall	.-94     	; 0x1ec60 <tracePGM>
	tracePGM(p_msg);
   1ecbe:	c8 01       	movw	r24, r16
}
   1ecc0:	df 91       	pop	r29
   1ecc2:	cf 91       	pop	r28
   1ecc4:	1f 91       	pop	r17
   1ecc6:	0f 91       	pop	r16

void tracePGMln(const void* p_prefix, const void* p_msg)
{
	tracePGM(mDebug_NEWLINE);
	tracePGM(p_prefix);
	tracePGM(p_msg);
   1ecc8:	cb cf       	rjmp	.-106    	; 0x1ec60 <tracePGM>

0001ecca <trace>:
}


void trace(char* msg)
{
   1ecca:	cf 93       	push	r28
   1eccc:	df 93       	push	r29
	uint8_t c;

	if(*msg != '\0') {
   1ecce:	fc 01       	movw	r30, r24
   1ecd0:	20 81       	ld	r18, Z
   1ecd2:	22 23       	and	r18, r18
   1ecd4:	31 f0       	breq	.+12     	; 0x1ece2 <trace+0x18>
   1ecd6:	ec 01       	movw	r28, r24
		while((c = *msg++)) putch(c);
   1ecd8:	89 91       	ld	r24, Y+
   1ecda:	88 23       	and	r24, r24
   1ecdc:	11 f0       	breq	.+4      	; 0x1ece2 <trace+0x18>
   1ecde:	4a d0       	rcall	.+148    	; 0x1ed74 <putch>
   1ece0:	fb cf       	rjmp	.-10     	; 0x1ecd8 <trace+0xe>
	}
}
   1ece2:	df 91       	pop	r29
   1ece4:	cf 91       	pop	r28
   1ece6:	08 95       	ret

0001ece8 <traceln>:


void traceln(const void* p_prefix, char* msg)
{
   1ece8:	0f 93       	push	r16
   1ecea:	1f 93       	push	r17
   1ecec:	cf 93       	push	r28
   1ecee:	df 93       	push	r29
   1ecf0:	ec 01       	movw	r28, r24
   1ecf2:	8b 01       	movw	r16, r22
	tracePGM(mDebug_NEWLINE);
   1ecf4:	87 ee       	ldi	r24, 0xE7	; 231
   1ecf6:	92 ee       	ldi	r25, 0xE2	; 226
   1ecf8:	b3 df       	rcall	.-154    	; 0x1ec60 <tracePGM>
	tracePGM(p_prefix);
   1ecfa:	ce 01       	movw	r24, r28
   1ecfc:	b1 df       	rcall	.-158    	; 0x1ec60 <tracePGM>
	trace(msg);
   1ecfe:	c8 01       	movw	r24, r16
}
   1ed00:	df 91       	pop	r29
   1ed02:	cf 91       	pop	r28
   1ed04:	1f 91       	pop	r17
   1ed06:	0f 91       	pop	r16

void traceln(const void* p_prefix, char* msg)
{
	tracePGM(mDebug_NEWLINE);
	tracePGM(p_prefix);
	trace(msg);
   1ed08:	e0 cf       	rjmp	.-64     	; 0x1ecca <trace>

0001ed0a <tracehex>:
}


void tracehex(uint32_t num, uint8_t len)
{
   1ed0a:	cf 92       	push	r12
   1ed0c:	df 92       	push	r13
   1ed0e:	ef 92       	push	r14
   1ed10:	ff 92       	push	r15
   1ed12:	cf 93       	push	r28
   1ed14:	6b 01       	movw	r12, r22
   1ed16:	7c 01       	movw	r14, r24
   1ed18:	c4 2f       	mov	r28, r20
	tracePGM(mDebug_HEXPREF);
   1ed1a:	84 ee       	ldi	r24, 0xE4	; 228
   1ed1c:	92 ee       	ldi	r25, 0xE2	; 226
   1ed1e:	a0 df       	rcall	.-192    	; 0x1ec60 <tracePGM>

	while(len > 0) {
   1ed20:	cc 23       	and	r28, r28
   1ed22:	a9 f0       	breq	.+42     	; 0x1ed4e <tracehex+0x44>
		puthex(num >> (4 * (len - 1)));
   1ed24:	8c 2f       	mov	r24, r28
   1ed26:	90 e0       	ldi	r25, 0x00	; 0
   1ed28:	01 97       	sbiw	r24, 0x01	; 1
   1ed2a:	88 0f       	add	r24, r24
   1ed2c:	99 1f       	adc	r25, r25
   1ed2e:	88 0f       	add	r24, r24
   1ed30:	99 1f       	adc	r25, r25
   1ed32:	a7 01       	movw	r20, r14
   1ed34:	96 01       	movw	r18, r12
   1ed36:	04 c0       	rjmp	.+8      	; 0x1ed40 <tracehex+0x36>
   1ed38:	56 95       	lsr	r21
   1ed3a:	47 95       	ror	r20
   1ed3c:	37 95       	ror	r19
   1ed3e:	27 95       	ror	r18
   1ed40:	8a 95       	dec	r24
   1ed42:	d2 f7       	brpl	.-12     	; 0x1ed38 <tracehex+0x2e>
   1ed44:	da 01       	movw	r26, r20
   1ed46:	c9 01       	movw	r24, r18
   1ed48:	1c d0       	rcall	.+56     	; 0x1ed82 <puthex>
		len--;
   1ed4a:	c1 50       	subi	r28, 0x01	; 1
   1ed4c:	e9 cf       	rjmp	.-46     	; 0x1ed20 <tracehex+0x16>
	}
}
   1ed4e:	cf 91       	pop	r28
   1ed50:	ff 90       	pop	r15
   1ed52:	ef 90       	pop	r14
   1ed54:	df 90       	pop	r13
   1ed56:	cf 90       	pop	r12
   1ed58:	08 95       	ret

0001ed5a <serialInit>:


void serialInit(void)
{
	// Double speed mode USART0
	UART_STATUS_REG		= _BV(UART_DOUBLE_SPEED);
   1ed5a:	82 e0       	ldi	r24, 0x02	; 2
   1ed5c:	80 93 c0 00 	sts	0x00C0, r24
	// Enable receiver and transiter on USART0
	UART_CONTROL_REG	= _BV(UART_ENABLE_RECEIVER) | _BV(UART_ENABLE_TRANSMITTER);
   1ed60:	88 e1       	ldi	r24, 0x18	; 24
   1ed62:	80 93 c1 00 	sts	0x00C1, r24
	// Set 8bit character length on USART0
	UART_MODE_REG		= _BV(UART_CHAR_SIZE_LOW) | _BV(UART_CHAR_SIZE_MID);
   1ed66:	86 e0       	ldi	r24, 0x06	; 6
   1ed68:	80 93 c2 00 	sts	0x00C2, r24
	// Set USART0 baud rate
	UART_BAUD_RATE_LOW	= (uint8_t)((F_CPU + BAUD_RATE * 4L) / (BAUD_RATE * 8L) - 1);
   1ed6c:	80 e1       	ldi	r24, 0x10	; 16
   1ed6e:	80 93 c4 00 	sts	0x00C4, r24
   1ed72:	08 95       	ret

0001ed74 <putch>:
}


void putch(uint8_t c)
{
	while(!(UART_STATUS_REG & _BV(UART_DATA_REG_EMPTY)));
   1ed74:	90 91 c0 00 	lds	r25, 0x00C0
   1ed78:	95 ff       	sbrs	r25, 5
   1ed7a:	fc cf       	rjmp	.-8      	; 0x1ed74 <putch>
	UART_DATA_REG = c;
   1ed7c:	80 93 c6 00 	sts	0x00C6, r24
   1ed80:	08 95       	ret

0001ed82 <puthex>:
}


void puthex(uint8_t c)
{
	c &= 0xf;
   1ed82:	8f 70       	andi	r24, 0x0F	; 15
	if(c > 9) c += 7;
   1ed84:	8a 30       	cpi	r24, 0x0A	; 10
   1ed86:	08 f0       	brcs	.+2      	; 0x1ed8a <puthex+0x8>
   1ed88:	89 5f       	subi	r24, 0xF9	; 249
	//while(!(UART_STATUS_REG & _BV(UART_DATA_REG_EMPTY)));
	//UART_DATA_REG = c + '0';
	putch(c + '0');
   1ed8a:	80 5d       	subi	r24, 0xD0	; 208
   1ed8c:	f3 cf       	rjmp	.-26     	; 0x1ed74 <putch>

0001ed8e <getch>:

uint8_t getch(void)
{
	//uint8_t ch;

	while(!(UART_STATUS_REG & _BV(UART_RECEIVE_COMPLETE)));
   1ed8e:	80 91 c0 00 	lds	r24, 0x00C0
   1ed92:	87 ff       	sbrs	r24, 7
   1ed94:	fc cf       	rjmp	.-8      	; 0x1ed8e <getch>
	if(!(UART_STATUS_REG & _BV(UART_FRAME_ERROR))) {
   1ed96:	80 91 c0 00 	lds	r24, 0x00C0
   1ed9a:	84 fd       	sbrc	r24, 4
   1ed9c:	01 c0       	rjmp	.+2      	; 0x1eda0 <getch+0x12>
		 * expects to be talking to the application, and DON'T reset the
		 * watchdog.  This should cause the bootloader to abort and run
		 * the application "soon", if it keeps happening.  (Note that we
		 * don't care that an invalid char is returned...)
		 */
		wdt_reset();
   1ed9e:	a8 95       	wdr
	}

	//ch = UART_DATA_REG;
	//return ch;

	return(UART_DATA_REG);
   1eda0:	80 91 c6 00 	lds	r24, 0x00C6
}
   1eda4:	08 95       	ret

0001eda6 <serialPoll>:


uint8_t serialPoll(void)
{
	if(UART_STATUS_REG & _BV(UART_RECEIVE_COMPLETE)) {
   1eda6:	80 91 c0 00 	lds	r24, 0x00C0
   1edaa:	87 ff       	sbrs	r24, 7
   1edac:	05 c0       	rjmp	.+10     	; 0x1edb8 <serialPoll+0x12>
		resetTick();
   1edae:	28 d0       	rcall	.+80     	; 0x1ee00 <resetTick>
		serialFlashing = TRUE;
   1edb0:	81 e0       	ldi	r24, 0x01	; 1
   1edb2:	80 93 29 01 	sts	0x0129, r24
#if defined(__AVR_ATmega328__) || defined(__AVR_ATmega328P__) || defined(__AVR_ATmega1284P__)
		return(processOptiboot());
   1edb6:	53 c0       	rjmp	.+166    	; 0x1ee5e <processOptiboot>
#elif defined(__AVR_ATmega2560__)
		return(processStk500boot());
#endif
	}
	return(1);
}
   1edb8:	81 e0       	ldi	r24, 0x01	; 1
   1edba:	08 95       	ret

0001edbc <updateLed>:
static uint16_t tick = 0;


void updateLed(void)
{
	uint16_t next_timer_1 = TCNT1;
   1edbc:	80 91 84 00 	lds	r24, 0x0084
   1edc0:	90 91 85 00 	lds	r25, 0x0085

	if(next_timer_1 & 0x400) LED_PORT ^= _BV(LED); // Led pin high
   1edc4:	92 ff       	sbrs	r25, 2
   1edc6:	05 c0       	rjmp	.+10     	; 0x1edd2 <updateLed+0x16>
   1edc8:	2b b1       	in	r18, 0x0b	; 11
   1edca:	30 e2       	ldi	r19, 0x20	; 32
   1edcc:	23 27       	eor	r18, r19
   1edce:	2b b9       	out	0x0b, r18	; 11
   1edd0:	01 c0       	rjmp	.+2      	; 0x1edd4 <updateLed+0x18>
	else LED_PORT &= ~_BV(LED); // Led pin low
   1edd2:	5d 98       	cbi	0x0b, 5	; 11

	if(next_timer_1 < last_timer_1) {
   1edd4:	20 91 22 01 	lds	r18, 0x0122
   1edd8:	30 91 23 01 	lds	r19, 0x0123
   1eddc:	82 17       	cp	r24, r18
   1edde:	93 07       	cpc	r25, r19
   1ede0:	50 f4       	brcc	.+20     	; 0x1edf6 <updateLed+0x3a>
		tick++;
   1ede2:	20 91 20 01 	lds	r18, 0x0120
   1ede6:	30 91 21 01 	lds	r19, 0x0121
   1edea:	2f 5f       	subi	r18, 0xFF	; 255
   1edec:	3f 4f       	sbci	r19, 0xFF	; 255
   1edee:	30 93 21 01 	sts	0x0121, r19
   1edf2:	20 93 20 01 	sts	0x0120, r18
		    tracePGMlnUtil(mDebugUtil_LAST);
		    tracenum(last_timer_1);
		)
	}

	last_timer_1 = next_timer_1;
   1edf6:	90 93 23 01 	sts	0x0123, r25
   1edfa:	80 93 22 01 	sts	0x0122, r24
   1edfe:	08 95       	ret

0001ee00 <resetTick>:
}

void resetTick(void)
{
	TCNT1 = 0;
   1ee00:	10 92 85 00 	sts	0x0085, r1
   1ee04:	10 92 84 00 	sts	0x0084, r1
	tick = 0;
   1ee08:	10 92 21 01 	sts	0x0121, r1
   1ee0c:	10 92 20 01 	sts	0x0120, r1
   1ee10:	08 95       	ret

0001ee12 <timedOut>:

uint8_t timedOut(void)
{
	// Never timeout if there is no code in Flash
#if (FLASHEND > 0x10000)
	if(pgm_read_word_far(0x0000) == 0xFFFF) return(0);
   1ee12:	80 e0       	ldi	r24, 0x00	; 0
   1ee14:	90 e0       	ldi	r25, 0x00	; 0
   1ee16:	dc 01       	movw	r26, r24
   1ee18:	ab bf       	out	0x3b, r26	; 59
   1ee1a:	fc 01       	movw	r30, r24
   1ee1c:	87 91       	elpm	r24, Z+
   1ee1e:	96 91       	elpm	r25, Z
   1ee20:	01 96       	adiw	r24, 0x01	; 1
   1ee22:	41 f0       	breq	.+16     	; 0x1ee34 <timedOut+0x22>
#else
	if(pgm_read_word_near(0x0000) == 0xFFFF) return(0);
#endif

	if(tick > TIMEOUT) return(1);
   1ee24:	81 e0       	ldi	r24, 0x01	; 1
   1ee26:	20 91 20 01 	lds	r18, 0x0120
   1ee2a:	30 91 21 01 	lds	r19, 0x0121
   1ee2e:	25 30       	cpi	r18, 0x05	; 5
   1ee30:	31 05       	cpc	r19, r1
   1ee32:	08 f4       	brcc	.+2      	; 0x1ee36 <timedOut+0x24>

uint8_t timedOut(void)
{
	// Never timeout if there is no code in Flash
#if (FLASHEND > 0x10000)
	if(pgm_read_word_far(0x0000) == 0xFFFF) return(0);
   1ee34:	80 e0       	ldi	r24, 0x00	; 0
	if(pgm_read_word_near(0x0000) == 0xFFFF) return(0);
#endif

	if(tick > TIMEOUT) return(1);
	else return(0);
}
   1ee36:	08 95       	ret

0001ee38 <verifySpace>:
static uint16_t address = 0;
static uint8_t  length;

static void verifySpace(void)
{
	if(getch() != CRC_EOP) {
   1ee38:	aa df       	rcall	.-172    	; 0x1ed8e <getch>
   1ee3a:	80 32       	cpi	r24, 0x20	; 32
   1ee3c:	39 f0       	breq	.+14     	; 0x1ee4c <verifySpace+0x14>
		WDTCSR = _BV(WDCE) | _BV(WDE);
   1ee3e:	88 e1       	ldi	r24, 0x18	; 24
   1ee40:	80 93 60 00 	sts	0x0060, r24
		WDTCSR = WATCHDOG_16MS;	// shorten WD timeout
   1ee44:	88 e0       	ldi	r24, 0x08	; 8
   1ee46:	80 93 60 00 	sts	0x0060, r24
   1ee4a:	ff cf       	rjmp	.-2      	; 0x1ee4a <verifySpace+0x12>
		while(1)				// and busy-loop so that WD causes
			;					// a reset and app start.
	}
	putch(STK_INSYNC);
   1ee4c:	84 e1       	ldi	r24, 0x14	; 20
   1ee4e:	92 cf       	rjmp	.-220    	; 0x1ed74 <putch>

0001ee50 <getNch>:
}


static void getNch(uint8_t count)
{
   1ee50:	cf 93       	push	r28
   1ee52:	c8 2f       	mov	r28, r24
	do getch();
   1ee54:	9c df       	rcall	.-200    	; 0x1ed8e <getch>
	while(--count);
   1ee56:	c1 50       	subi	r28, 0x01	; 1
   1ee58:	e9 f7       	brne	.-6      	; 0x1ee54 <getNch+0x4>
	verifySpace();
}
   1ee5a:	cf 91       	pop	r28

static void getNch(uint8_t count)
{
	do getch();
	while(--count);
	verifySpace();
   1ee5c:	ed cf       	rjmp	.-38     	; 0x1ee38 <verifySpace>

0001ee5e <processOptiboot>:
}


uint8_t processOptiboot(void)
{
   1ee5e:	cf 92       	push	r12
   1ee60:	df 92       	push	r13
   1ee62:	ef 92       	push	r14
   1ee64:	ff 92       	push	r15
   1ee66:	0f 93       	push	r16
   1ee68:	1f 93       	push	r17
   1ee6a:	cf 93       	push	r28
   1ee6c:	df 93       	push	r29
   1ee6e:	cd b7       	in	r28, 0x3d	; 61
   1ee70:	de b7       	in	r29, 0x3e	; 62
   1ee72:	c1 50       	subi	r28, 0x01	; 1
   1ee74:	d1 40       	sbci	r29, 0x01	; 1
   1ee76:	de bf       	out	0x3e, r29	; 62
   1ee78:	cd bf       	out	0x3d, r28	; 61
	uint8_t ch;

	ch = getch();
   1ee7a:	89 df       	rcall	.-238    	; 0x1ed8e <getch>

	if(ch == STK_GET_PARAMETER) {
   1ee7c:	81 34       	cpi	r24, 0x41	; 65
   1ee7e:	a9 f4       	brne	.+42     	; 0x1eeaa <processOptiboot+0x4c>
		unsigned char which = getch();
   1ee80:	86 df       	rcall	.-244    	; 0x1ed8e <getch>
		verifySpace();
   1ee82:	cf 5f       	subi	r28, 0xFF	; 255
   1ee84:	de 4f       	sbci	r29, 0xFE	; 254
   1ee86:	88 83       	st	Y, r24
   1ee88:	c1 50       	subi	r28, 0x01	; 1
   1ee8a:	d1 40       	sbci	r29, 0x01	; 1
   1ee8c:	d5 df       	rcall	.-86     	; 0x1ee38 <verifySpace>
		if(which == 0x82) {
   1ee8e:	cf 5f       	subi	r28, 0xFF	; 255
   1ee90:	de 4f       	sbci	r29, 0xFE	; 254
   1ee92:	88 81       	ld	r24, Y
   1ee94:	c1 50       	subi	r28, 0x01	; 1
   1ee96:	d1 40       	sbci	r29, 0x01	; 1
   1ee98:	82 38       	cpi	r24, 0x82	; 130
   1ee9a:	11 f4       	brne	.+4      	; 0x1eea0 <processOptiboot+0x42>
			/*
			 * Send tftpboot version as "minor SW version"
			 */
			putch(ARIADNE_MINVER);
   1ee9c:	84 e0       	ldi	r24, 0x04	; 4
   1ee9e:	03 c0       	rjmp	.+6      	; 0x1eea6 <processOptiboot+0x48>
		} else if(which == 0x81) {
   1eea0:	81 38       	cpi	r24, 0x81	; 129
   1eea2:	21 f1       	breq	.+72     	; 0x1eeec <processOptiboot+0x8e>
		} else {
			/*
			 * GET PARAMETER returns a generic 0x03 reply for
			 * other parameters - enough to keep Avrdude happy
			 */
			putch(0x03);
   1eea4:	83 e0       	ldi	r24, 0x03	; 3
   1eea6:	66 df       	rcall	.-308    	; 0x1ed74 <putch>
   1eea8:	ca c0       	rjmp	.+404    	; 0x1f03e <processOptiboot+0x1e0>
		}
	} else if(ch == STK_SET_DEVICE) {
   1eeaa:	82 34       	cpi	r24, 0x42	; 66
   1eeac:	11 f4       	brne	.+4      	; 0x1eeb2 <processOptiboot+0x54>
		// SET DEVICE is ignored
		getNch(20);
   1eeae:	84 e1       	ldi	r24, 0x14	; 20
   1eeb0:	03 c0       	rjmp	.+6      	; 0x1eeb8 <processOptiboot+0x5a>
	} else if(ch == STK_SET_DEVICE_EXT) {
   1eeb2:	85 34       	cpi	r24, 0x45	; 69
   1eeb4:	19 f4       	brne	.+6      	; 0x1eebc <processOptiboot+0x5e>
		// SET DEVICE EXT is ignored
		getNch(4);
   1eeb6:	84 e0       	ldi	r24, 0x04	; 4
   1eeb8:	cb df       	rcall	.-106    	; 0x1ee50 <getNch>
   1eeba:	c1 c0       	rjmp	.+386    	; 0x1f03e <processOptiboot+0x1e0>
	} else if(ch == STK_LOAD_ADDRESS) {
   1eebc:	85 35       	cpi	r24, 0x55	; 85
   1eebe:	91 f4       	brne	.+36     	; 0x1eee4 <processOptiboot+0x86>
		// LOAD ADDRESS
		uint16_t newAddress;
		newAddress = getch();
   1eec0:	66 df       	rcall	.-308    	; 0x1ed8e <getch>
   1eec2:	18 2f       	mov	r17, r24
		newAddress = (newAddress & 0xff) | (getch() << 8);
   1eec4:	64 df       	rcall	.-312    	; 0x1ed8e <getch>
   1eec6:	21 2f       	mov	r18, r17
   1eec8:	30 e0       	ldi	r19, 0x00	; 0
   1eeca:	38 2b       	or	r19, r24

#ifdef RAMPZ
		// Transfer top bit to RAMPZ
		RAMPZ = (newAddress & 0x8000) ? 1 : 0;
   1eecc:	83 2f       	mov	r24, r19
   1eece:	88 1f       	adc	r24, r24
   1eed0:	88 27       	eor	r24, r24
   1eed2:	88 1f       	adc	r24, r24
   1eed4:	8b bf       	out	0x3b, r24	; 59
#endif

		newAddress += newAddress; // Convert from word address to byte address
   1eed6:	22 0f       	add	r18, r18
   1eed8:	33 1f       	adc	r19, r19
		address = newAddress;
   1eeda:	30 93 26 01 	sts	0x0126, r19
   1eede:	20 93 25 01 	sts	0x0125, r18
   1eee2:	ac c0       	rjmp	.+344    	; 0x1f03c <processOptiboot+0x1de>
		verifySpace();
	} else if(ch == STK_UNIVERSAL) {
   1eee4:	86 35       	cpi	r24, 0x56	; 86
   1eee6:	21 f4       	brne	.+8      	; 0x1eef0 <processOptiboot+0x92>
		// UNIVERSAL command is ignored
		getNch(4);
   1eee8:	84 e0       	ldi	r24, 0x04	; 4
   1eeea:	b2 df       	rcall	.-156    	; 0x1ee50 <getNch>
		putch(0x00);
   1eeec:	80 e0       	ldi	r24, 0x00	; 0
   1eeee:	db cf       	rjmp	.-74     	; 0x1eea6 <processOptiboot+0x48>
	}
	/* Write memory, length is big endian and is in bytes */
	else if(ch == STK_PROG_PAGE) {
   1eef0:	84 36       	cpi	r24, 0x64	; 100
   1eef2:	09 f0       	breq	.+2      	; 0x1eef6 <processOptiboot+0x98>
   1eef4:	70 c0       	rjmp	.+224    	; 0x1efd6 <processOptiboot+0x178>
		// PROGRAM PAGE - we support flash programming only, not EEPROM
		uint8_t  buff[256];
		uint8_t* bufPtr;
		uint16_t addrPtr;

		getch();			/* getlen() */
   1eef6:	4b df       	rcall	.-362    	; 0x1ed8e <getch>
		length = getch();
   1eef8:	4a df       	rcall	.-364    	; 0x1ed8e <getch>
   1eefa:	80 93 24 01 	sts	0x0124, r24
		getch();
   1eefe:	47 df       	rcall	.-370    	; 0x1ed8e <getch>

		// If we are in RWW section, immediately start page erase
		if(address < NRWWSTART) boot_page_erase((uint16_t)(void*)address);
   1ef00:	80 91 25 01 	lds	r24, 0x0125
   1ef04:	90 91 26 01 	lds	r25, 0x0126
   1ef08:	81 15       	cp	r24, r1
   1ef0a:	20 ee       	ldi	r18, 0xE0	; 224
   1ef0c:	92 07       	cpc	r25, r18
   1ef0e:	48 f4       	brcc	.+18     	; 0x1ef22 <processOptiboot+0xc4>
   1ef10:	a0 e0       	ldi	r26, 0x00	; 0
   1ef12:	b0 e0       	ldi	r27, 0x00	; 0
   1ef14:	23 e0       	ldi	r18, 0x03	; 3
   1ef16:	fc 01       	movw	r30, r24
   1ef18:	a0 93 5b 00 	sts	0x005B, r26
   1ef1c:	20 93 57 00 	sts	0x0057, r18
   1ef20:	e8 95       	spm
   1ef22:	ce 01       	movw	r24, r28
   1ef24:	01 96       	adiw	r24, 0x01	; 1
   1ef26:	7c 01       	movw	r14, r24
   1ef28:	8c 01       	movw	r16, r24

		// While that is going on, read in page contents
		bufPtr = buff;
		do* bufPtr++ = getch();
   1ef2a:	31 df       	rcall	.-414    	; 0x1ed8e <getch>
   1ef2c:	f7 01       	movw	r30, r14
   1ef2e:	81 93       	st	Z+, r24
   1ef30:	7f 01       	movw	r14, r30
		while(--length);
   1ef32:	80 91 24 01 	lds	r24, 0x0124
   1ef36:	81 50       	subi	r24, 0x01	; 1
   1ef38:	80 93 24 01 	sts	0x0124, r24
   1ef3c:	81 11       	cpse	r24, r1
   1ef3e:	f5 cf       	rjmp	.-22     	; 0x1ef2a <processOptiboot+0xcc>

		// If we are in NRWW section, page erase has to be delayed until now.
		// Todo: Take RAMPZ into account
		if(address >= NRWWSTART) boot_page_erase((uint16_t)(void*)address);
   1ef40:	80 91 25 01 	lds	r24, 0x0125
   1ef44:	90 91 26 01 	lds	r25, 0x0126
   1ef48:	81 15       	cp	r24, r1
   1ef4a:	f0 ee       	ldi	r31, 0xE0	; 224
   1ef4c:	9f 07       	cpc	r25, r31
   1ef4e:	48 f0       	brcs	.+18     	; 0x1ef62 <processOptiboot+0x104>
   1ef50:	a0 e0       	ldi	r26, 0x00	; 0
   1ef52:	b0 e0       	ldi	r27, 0x00	; 0
   1ef54:	23 e0       	ldi	r18, 0x03	; 3
   1ef56:	fc 01       	movw	r30, r24
   1ef58:	a0 93 5b 00 	sts	0x005B, r26
   1ef5c:	20 93 57 00 	sts	0x0057, r18
   1ef60:	e8 95       	spm

		// Read command terminator, start reply
		verifySpace();
   1ef62:	6a df       	rcall	.-300    	; 0x1ee38 <verifySpace>

		// If only a partial page is to be programmed, the erase might not be complete.
		// So check that here
		boot_spm_busy_wait();
   1ef64:	07 b6       	in	r0, 0x37	; 55
   1ef66:	00 fc       	sbrc	r0, 0
   1ef68:	fd cf       	rjmp	.-6      	; 0x1ef64 <processOptiboot+0x106>

		// Copy buffer into programming buffer
		bufPtr = buff;
		addrPtr = (uint16_t)(void*)address;
   1ef6a:	80 91 25 01 	lds	r24, 0x0125
   1ef6e:	90 91 26 01 	lds	r25, 0x0126
		// If only a partial page is to be programmed, the erase might not be complete.
		// So check that here
		boot_spm_busy_wait();

		// Copy buffer into programming buffer
		bufPtr = buff;
   1ef72:	a9 81       	ldd	r26, Y+1	; 0x01
   1ef74:	20 e0       	ldi	r18, 0x00	; 0
   1ef76:	30 e0       	ldi	r19, 0x00	; 0
		ch = SPM_PAGESIZE / 2;
		do {
			uint16_t a;
			a = *bufPtr++;
			a |= (*bufPtr++) << 8;
			boot_page_fill((uint16_t)(void*)addrPtr, a);
   1ef78:	dd 24       	eor	r13, r13
   1ef7a:	d3 94       	inc	r13
   1ef7c:	78 01       	movw	r14, r16
   1ef7e:	e2 0e       	add	r14, r18
   1ef80:	f3 1e       	adc	r15, r19
   1ef82:	a9 01       	movw	r20, r18
   1ef84:	48 0f       	add	r20, r24
   1ef86:	59 1f       	adc	r21, r25
   1ef88:	60 e0       	ldi	r22, 0x00	; 0
   1ef8a:	70 e0       	ldi	r23, 0x00	; 0
		addrPtr = (uint16_t)(void*)address;
		ch = SPM_PAGESIZE / 2;
		do {
			uint16_t a;
			a = *bufPtr++;
			a |= (*bufPtr++) << 8;
   1ef8c:	f7 01       	movw	r30, r14
   1ef8e:	c1 80       	ldd	r12, Z+1	; 0x01
   1ef90:	b0 e0       	ldi	r27, 0x00	; 0
   1ef92:	bc 29       	or	r27, r12
			boot_page_fill((uint16_t)(void*)addrPtr, a);
   1ef94:	0d 01       	movw	r0, r26
   1ef96:	fa 01       	movw	r30, r20
   1ef98:	60 93 5b 00 	sts	0x005B, r22
   1ef9c:	d0 92 57 00 	sts	0x0057, r13
   1efa0:	e8 95       	spm
   1efa2:	11 24       	eor	r1, r1
			addrPtr += 2;
		} while(--ch);
   1efa4:	2e 3f       	cpi	r18, 0xFE	; 254
   1efa6:	31 05       	cpc	r19, r1
   1efa8:	29 f0       	breq	.+10     	; 0x1efb4 <processOptiboot+0x156>
   1efaa:	2e 5f       	subi	r18, 0xFE	; 254
   1efac:	3f 4f       	sbci	r19, 0xFF	; 255
		addrPtr = (uint16_t)(void*)address;
		ch = SPM_PAGESIZE / 2;
		do {
			uint16_t a;
			a = *bufPtr++;
			a |= (*bufPtr++) << 8;
   1efae:	f7 01       	movw	r30, r14
   1efb0:	a2 81       	ldd	r26, Z+2	; 0x02
   1efb2:	e4 cf       	rjmp	.-56     	; 0x1ef7c <processOptiboot+0x11e>
			boot_page_fill((uint16_t)(void*)addrPtr, a);
			addrPtr += 2;
		} while(--ch);

		// Write from programming buffer
		boot_page_write((uint16_t)(void*)address);
   1efb4:	a0 e0       	ldi	r26, 0x00	; 0
   1efb6:	b0 e0       	ldi	r27, 0x00	; 0
   1efb8:	25 e0       	ldi	r18, 0x05	; 5
   1efba:	fc 01       	movw	r30, r24
   1efbc:	a0 93 5b 00 	sts	0x005B, r26
   1efc0:	20 93 57 00 	sts	0x0057, r18
   1efc4:	e8 95       	spm
		boot_spm_busy_wait();
   1efc6:	07 b6       	in	r0, 0x37	; 55
   1efc8:	00 fc       	sbrc	r0, 0
   1efca:	fd cf       	rjmp	.-6      	; 0x1efc6 <processOptiboot+0x168>

#if defined(RWWSRE)
		// Reenable read access to flash
		boot_rww_enable();
   1efcc:	81 e1       	ldi	r24, 0x11	; 17
   1efce:	80 93 57 00 	sts	0x0057, r24
   1efd2:	e8 95       	spm
   1efd4:	34 c0       	rjmp	.+104    	; 0x1f03e <processOptiboot+0x1e0>
#endif
	}
	/* Read memory block mode, length is big endian.  */
	else if(ch == STK_READ_PAGE) {
   1efd6:	84 37       	cpi	r24, 0x74	; 116
   1efd8:	e9 f4       	brne	.+58     	; 0x1f014 <processOptiboot+0x1b6>
		// READ PAGE - we only read flash
		getch();			/* getlen() */
   1efda:	d9 de       	rcall	.-590    	; 0x1ed8e <getch>
		length = getch();
   1efdc:	d8 de       	rcall	.-592    	; 0x1ed8e <getch>
   1efde:	80 93 24 01 	sts	0x0124, r24
		getch();
   1efe2:	d5 de       	rcall	.-598    	; 0x1ed8e <getch>

		verifySpace();
   1efe4:	29 df       	rcall	.-430    	; 0x1ee38 <verifySpace>

		//      do putch(pgm_read_byte_near(address++));
		//      while (--length);
		do {
			uint8_t result;
			__asm__("elpm %0,Z\n":"=r"(result):"z"(address));
   1efe6:	e0 91 25 01 	lds	r30, 0x0125
   1efea:	f0 91 26 01 	lds	r31, 0x0126
   1efee:	86 91       	elpm	r24, Z
			putch(result);
   1eff0:	c1 de       	rcall	.-638    	; 0x1ed74 <putch>
			address++;
   1eff2:	80 91 25 01 	lds	r24, 0x0125
   1eff6:	90 91 26 01 	lds	r25, 0x0126
   1effa:	01 96       	adiw	r24, 0x01	; 1
   1effc:	90 93 26 01 	sts	0x0126, r25
   1f000:	80 93 25 01 	sts	0x0125, r24
		} while(--length);
   1f004:	80 91 24 01 	lds	r24, 0x0124
   1f008:	81 50       	subi	r24, 0x01	; 1
   1f00a:	80 93 24 01 	sts	0x0124, r24
   1f00e:	81 11       	cpse	r24, r1
   1f010:	ea cf       	rjmp	.-44     	; 0x1efe6 <processOptiboot+0x188>
   1f012:	15 c0       	rjmp	.+42     	; 0x1f03e <processOptiboot+0x1e0>
		do putch(pgm_read_byte_near(address++));
		while(--length);
#endif
	}
	/* Get device signature bytes  */
	else if(ch == STK_READ_SIGN) {
   1f014:	85 37       	cpi	r24, 0x75	; 117
   1f016:	39 f4       	brne	.+14     	; 0x1f026 <processOptiboot+0x1c8>
		// READ SIGN - return what Avrdude wants to hear
		verifySpace();
   1f018:	0f df       	rcall	.-482    	; 0x1ee38 <verifySpace>
		putch(SIGNATURE_0);
   1f01a:	8e e1       	ldi	r24, 0x1E	; 30
   1f01c:	ab de       	rcall	.-682    	; 0x1ed74 <putch>
		putch(SIGNATURE_1);
   1f01e:	87 e9       	ldi	r24, 0x97	; 151
   1f020:	a9 de       	rcall	.-686    	; 0x1ed74 <putch>
		putch(SIGNATURE_2);
   1f022:	85 e0       	ldi	r24, 0x05	; 5
   1f024:	40 cf       	rjmp	.-384    	; 0x1eea6 <processOptiboot+0x48>
	} else if(ch == STK_LEAVE_PROGMODE) {
   1f026:	81 35       	cpi	r24, 0x51	; 81
   1f028:	49 f4       	brne	.+18     	; 0x1f03c <processOptiboot+0x1de>
		// Adaboot no-wait mod
		//watchdogConfig(WATCHDOG_16MS);
		verifySpace();
   1f02a:	06 df       	rcall	.-500    	; 0x1ee38 <verifySpace>
		eeprom_write_byte(EEPROM_IMG_STAT, EEPROM_IMG_OK_VALUE);
   1f02c:	6e ee       	ldi	r22, 0xEE	; 238
   1f02e:	82 e0       	ldi	r24, 0x02	; 2
   1f030:	90 e0       	ldi	r25, 0x00	; 0
   1f032:	27 d0       	rcall	.+78     	; 0x1f082 <__eewr_byte_m1284p>
		putch(STK_OK);
   1f034:	80 e1       	ldi	r24, 0x10	; 16
   1f036:	9e de       	rcall	.-708    	; 0x1ed74 <putch>
		return(0);
   1f038:	80 e0       	ldi	r24, 0x00	; 0
   1f03a:	04 c0       	rjmp	.+8      	; 0x1f044 <processOptiboot+0x1e6>
	} else {
		// This covers the response to commands like STK_ENTER_PROGMODE
		verifySpace();
   1f03c:	fd de       	rcall	.-518    	; 0x1ee38 <verifySpace>
	}
	putch(STK_OK);
   1f03e:	80 e1       	ldi	r24, 0x10	; 16
   1f040:	99 de       	rcall	.-718    	; 0x1ed74 <putch>
	return(1);
   1f042:	81 e0       	ldi	r24, 0x01	; 1
}
   1f044:	cf 5f       	subi	r28, 0xFF	; 255
   1f046:	de 4f       	sbci	r29, 0xFE	; 254
   1f048:	de bf       	out	0x3e, r29	; 62
   1f04a:	cd bf       	out	0x3d, r28	; 61
   1f04c:	df 91       	pop	r29
   1f04e:	cf 91       	pop	r28
   1f050:	1f 91       	pop	r17
   1f052:	0f 91       	pop	r16
   1f054:	ff 90       	pop	r15
   1f056:	ef 90       	pop	r14
   1f058:	df 90       	pop	r13
   1f05a:	cf 90       	pop	r12
   1f05c:	08 95       	ret

0001f05e <memcpy_PF>:
   1f05e:	6b bf       	out	0x3b, r22	; 59
   1f060:	fa 01       	movw	r30, r20
   1f062:	dc 01       	movw	r26, r24
   1f064:	02 c0       	rjmp	.+4      	; 0x1f06a <memcpy_PF+0xc>
   1f066:	07 90       	elpm	r0, Z+
   1f068:	0d 92       	st	X+, r0
   1f06a:	21 50       	subi	r18, 0x01	; 1
   1f06c:	30 40       	sbci	r19, 0x00	; 0
   1f06e:	d8 f7       	brcc	.-10     	; 0x1f066 <memcpy_PF+0x8>
   1f070:	08 95       	ret

0001f072 <__eerd_byte_m1284p>:
   1f072:	f9 99       	sbic	0x1f, 1	; 31
   1f074:	fe cf       	rjmp	.-4      	; 0x1f072 <__eerd_byte_m1284p>
   1f076:	92 bd       	out	0x22, r25	; 34
   1f078:	81 bd       	out	0x21, r24	; 33
   1f07a:	f8 9a       	sbi	0x1f, 0	; 31
   1f07c:	99 27       	eor	r25, r25
   1f07e:	80 b5       	in	r24, 0x20	; 32
   1f080:	08 95       	ret

0001f082 <__eewr_byte_m1284p>:
   1f082:	26 2f       	mov	r18, r22

0001f084 <__eewr_r18_m1284p>:
   1f084:	f9 99       	sbic	0x1f, 1	; 31
   1f086:	fe cf       	rjmp	.-4      	; 0x1f084 <__eewr_r18_m1284p>
   1f088:	1f ba       	out	0x1f, r1	; 31
   1f08a:	92 bd       	out	0x22, r25	; 34
   1f08c:	81 bd       	out	0x21, r24	; 33
   1f08e:	20 bd       	out	0x20, r18	; 32
   1f090:	0f b6       	in	r0, 0x3f	; 63
   1f092:	f8 94       	cli
   1f094:	fa 9a       	sbi	0x1f, 2	; 31
   1f096:	f9 9a       	sbi	0x1f, 1	; 31
   1f098:	0f be       	out	0x3f, r0	; 63
   1f09a:	01 96       	adiw	r24, 0x01	; 1
   1f09c:	08 95       	ret

0001f09e <_exit>:
   1f09e:	f8 94       	cli

0001f0a0 <__stop_program>:
   1f0a0:	ff cf       	rjmp	.-2      	; 0x1f0a0 <__stop_program>
